### 6051. 统计是给定字符串前缀的字符串数目

给你一个字符串数组 `words` 和一个字符串 `s` ，其中 `words[i]` 和 `s` 只包含 **小写英文字母** 。

请你返回 `words` 中是字符串 `s` **前缀** 的 **字符串数目** 。

一个字符串的 **前缀** 是出现在字符串开头的子字符串。**子字符串** 是一个字符串中的连续一段字符序列。

**示例 1：**

```
输入：words = ["a","b","c","ab","bc","abc"], s = "abc"
输出：3
解释：
words 中是 s = "abc" 前缀的字符串为：
"a" ，"ab" 和 "abc" 。
所以 words 中是字符串 s 前缀的字符串数目为 3 。
```

**示例 2：**

```
输入：words = ["a","a"], s = "aa"
输出：2
解释：
两个字符串都是 s 的前缀。
注意，相同的字符串可能在 words 中出现多次，它们应该被计数多次。
```

**提示：**

- `1 <= words.length <= 1000`
- `1 <= words[i].length, s.length <= 10`
- `words[i]` 和 `s` **只** 包含小写英文字母。

```cpp
// 哈希表即可，甚至不需要哈希，毕竟数据量真的很小
class Solution {
public:
    int countPrefixes(vector<string>& words, string s) {
        unordered_map<string, int> map;
        string t;
        for (auto c : s) {
            t += c;
            map[t]++;
        }
        int ans = 0;
        for (auto & w : words) {
            if (map[w] > 0) {
                ans++;
            }
        }
        return ans;
    }
};
```

### 6052. 最小平均差

给你一个下标从 **0** 开始长度为 `n` 的整数数组 `nums` 。

下标 `i` 处的 **平均差** 指的是 `nums` 中 **前** `i + 1` 个元素平均值和 **后** `n - i - 1` 个元素平均值的 **绝对差** 。两个平均值都需要 **向下取整** 到最近的整数。

请你返回产生 **最小平均差** 的下标。如果有多个下标最小平均差相等，请你返回 **最小** 的一个下标。

**注意：**

- 两个数的 **绝对差** 是两者差的绝对值。
-  `n` 个元素的平均值是 `n` 个元素之 **和** 除以（整数除法） `n` 。
- `0` 个元素的平均值视为 `0` 。

**示例 1：**

```
输入：nums = [2,5,3,9,5,3]
输出：3
解释：
- 下标 0 处的平均差为：|2 / 1 - (5 + 3 + 9 + 5 + 3) / 5| = |2 / 1 - 25 / 5| = |2 - 5| = 3 。
- 下标 1 处的平均差为：|(2 + 5) / 2 - (3 + 9 + 5 + 3) / 4| = |7 / 2 - 20 / 4| = |3 - 5| = 2 。
- 下标 2 处的平均差为：|(2 + 5 + 3) / 3 - (9 + 5 + 3) / 3| = |10 / 3 - 17 / 3| = |3 - 5| = 2 。
- 下标 3 处的平均差为：|(2 + 5 + 3 + 9) / 4 - (5 + 3) / 2| = |19 / 4 - 8 / 2| = |4 - 4| = 0 。 
- 下标 4 处的平均差为：|(2 + 5 + 3 + 9 + 5) / 5 - 3 / 1| = |24 / 5 - 3 / 1| = |4 - 3| = 1 。
- 下标 5 处的平均差为：|(2 + 5 + 3 + 9 + 5 + 3) / 6 - 0| = |27 / 6 - 0| = |4 - 0| = 4 。
下标 3 处的平均差为最小平均差，所以返回 3 。
```

**示例 2：**

```
输入：nums = [0]
输出：0
解释：
唯一的下标是 0 ，所以我们返回 0 。
下标 0 处的平均差为：|0 / 1 - 0| = |0 - 0| = 0 。
```

**提示：**

- `1 <= nums.length <= 10^5`
- `0 <= nums[i] <= 10^5`

```cpp
class Solution {
public:
    int minimumAverageDifference(vector<int>& nums) {
        long long sum = 0;
        for (auto num : nums) {
            sum += num;
        }
        int ans = INT_MAX, ret;
        long long prev = 0, next;
        for (int i = 0; i < nums.size(); i++) {
            prev = prev + nums[i]; // 前缀和
            next = sum - prev; // 后缀和
            int temp;
            if (i == nums.size() - 1) {
                temp = abs((int)(prev / (i + 1)));
            } else {
                temp = abs((int)(prev / (i + 1) - next / (nums.size() - i - 1)));
            }
            if (temp < ans) {
                ans = temp, ret = i;
            }
        }
        return ret;
    }
};
```

### 6053. 统计网格图中没有被保卫的格子数

给你两个整数 `m` 和 `n` 表示一个下标从 **0** 开始的 `m x n` 网格图。同时给你两个二维整数数组 `guards` 和 `walls` ，其中 `guards[i] = [rowi, coli]` 且 `walls[j] = [rowj, colj]` ，分别表示第 `i` 个警卫和第 `j` 座墙所在的位置。

一个警卫能看到 4 个坐标轴方向（即东、南、西、北）的 **所有** 格子，除非他们被一座墙或者另外一个警卫 **挡住** 了视线。如果一个格子能被 **至少** 一个警卫看到，那么我们说这个格子被 **保卫** 了。

请你返回空格子中，有多少个格子是 **没被保卫** 的。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2022/03/10/example1drawio2.png)

```
输入：m = 4, n = 6, guards = [[0,0],[1,1],[2,3]], walls = [[0,1],[2,2],[1,4]]
输出：7
解释：上图中，被保卫和没有被保卫的格子分别用红色和绿色表示。
总共有 7 个没有被保卫的格子，所以我们返回 7 。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2022/03/10/example2drawio.png)

```
输入：m = 3, n = 3, guards = [[1,1]], walls = [[0,1],[1,0],[2,1],[1,2]]
输出：4
解释：上图中，没有被保卫的格子用绿色表示。
总共有 4 个没有被保卫的格子，所以我们返回 4 。
```

**提示：**

- `1 <= m, n <= 10^5`
- `2 <= m * n <= 10^5`
- `1 <= guards.length, walls.length <= 5 * 10^4`
- `2 <= guards.length + walls.length <= m * n`
- `guards[i].length == walls[j].length == 2`
- `0 <= rowi, rowj < m`
- `0 <= coli, colj < n`
- `guards` 和 `walls` 中所有位置 **互不相同** 。

很遗憾，这个题没有做出来，甚至毫无头绪，主要就是没有认真看题。没有看到第二个条件，因此觉得这个题很难做，最后因为实在想不出复杂度低的做法放弃了。

大概是因为蓝桥杯吧，在大家眼里我准备了这么久，最后颗粒无收，有点尴尬。确实，我感觉这种想法一定程度上影响了我，太过于在意别人的看法，但是其实别人根本懒得注意你（不排除某些人确实会特别关注）。做好自己，不要虚浮，流于表面。好好的去钻研，去学习。

```cpp
int dir[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
class Solution {
public:
    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {
        int ans = 0;
        vector<vector<int>> graph(m,  vector<int>(n, 0));
        for (auto & g : guards) {
            graph[g[0]][g[1]] = 1;
        }
        for (auto & w : walls) {
            graph[w[0]][w[1]] = 2;
        }
        // 这里遍历 guard 是最好的选择，这样时间复杂度最坏是 5 * 10^9 
        // 但是，当 guard 数量多的时候，中途 break 的概率较大
        // 如果数量少的时候，那么复杂度也就低了
        // 如果我们遍历单个元素，那么复杂度是 O(mn * (m + n)) ,最坏达到 10^10
        // 如果中途 break 的数量少，就很容易达到最坏情况
        for (int q = 0; q < guards.size(); q++) {
            int i = guards[q][0], j = guards[q][1];
            for (int k = 0; k < 4; k++) {
                int xx = i, yy = j;
                do {
                    int x = xx + dir[k][0], y = yy + dir[k][1];
                    if (0 <= x && x < m && 0 <= y && y < n) {
                        if (graph[x][y] == 1 || graph[x][y] == 2) {
                            break;
                        } else {
                            graph[x][y] = 3;
                            xx = x, yy = y;
                        }
                    } else {
                        break;
                    }
                } while (true);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (graph[i][j] == 0) ans++;
            }
        }
        return ans;
    }
};
```

### 6054. 逃离火灾

给你一个下标从 **0** 开始大小为 `m x n` 的二维整数数组 `grid` ，它表示一个网格图。每个格子为下面 3 个值之一：

- `0` 表示草地。
- `1` 表示着火的格子。
- `2` 表示一座墙，你跟火都不能通过这个格子。

一开始你在最左上角的格子 `(0, 0)` ，你想要到达最右下角的安全屋格子 `(m - 1, n - 1)` 。每一分钟，你可以移动到 **相邻** 的草地格子。每次你移动 **之后** ，着火的格子会扩散到所有不是墙的 **相邻** 格子。

请你返回你在初始位置可以停留的 **最多** 分钟数，且停留完这段时间后你还能安全到达安全屋。如果无法实现，请你返回 `-1` 。如果不管你在初始位置停留多久，你 **总是** 能到达安全屋，请你返回 `10^9` 。

注意，如果你到达安全屋后，火马上到了安全屋，这视为你能够安全到达安全屋。

如果两个格子有共同边，那么它们为 **相邻** 格子。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2022/03/10/ex1new.jpg)

```
输入：grid = [[0,2,0,0,0,0,0],[0,0,0,2,2,1,0],[0,2,0,0,1,2,0],[0,0,2,2,2,0,2],[0,0,0,0,0,0,0]]
输出：3
解释：上图展示了你在初始位置停留 3 分钟后的情形。
你仍然可以安全到达安全屋。
停留超过 3 分钟会让你无法安全到达安全屋。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2022/03/10/ex2new2.jpg)

```
输入：grid = [[0,0,0,0],[0,1,2,0],[0,2,0,0]]
输出：-1
解释：上图展示了你马上开始朝安全屋移动的情形。
火会蔓延到你可以移动的所有格子，所以无法安全到达安全屋。
所以返回 -1 。
```

**示例 3：**

![img](https://assets.leetcode.com/uploads/2022/03/10/ex3new.jpg)

```
输入：grid = [[0,0,0],[2,2,0],[1,2,0]]
输出：1000000000
解释：上图展示了初始网格图。
注意，由于火被墙围了起来，所以无论如何你都能安全到达安全屋。
所以返回 10^9 。
```

**提示：**

- `m == grid.length`
- `n == grid[i].length`
- `2 <= m, n <= 300`
- `4 <= m * n <= 2 * 10^4`
- `grid[i][j]` 是 `0` ，`1` 或者 `2` 。
- `grid[0][0] == grid[m - 1][n - 1] == 0`

```

```

