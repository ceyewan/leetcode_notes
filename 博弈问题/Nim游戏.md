> 你和你的朋友，两个人一起玩 Nim 游戏：
>
> 桌子上有一堆石头。
> 你们轮流进行自己的回合， 你作为先手 。
> 每一回合，轮到的人拿掉 1 - 3 块石头。
> 拿掉最后一块石头的人就是获胜者。
> 假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 n 的情况下赢得游戏。如果可以赢，返回 true；否则，返回 false 。

示例 1：

```
输入：n = 4
输出：false 
解释：以下是可能的结果:

1. 移除1颗石头。你的朋友移走了3块石头，包括最后一块。你的朋友赢了。
2. 移除2个石子。你的朋友移走2块石头，包括最后一块。你的朋友赢了。
   3.你移走3颗石子。你的朋友移走了最后一块石头。你的朋友赢了。
   在所有结果中，你的朋友是赢家。
```

示例 2：

```
输入：n = 1
输出：true
```

示例 3：

```
输入：n = 2
输出：true
```


提示：

- 1 <= n <= 2^31 - 1

四个一组四个一组分好组。如果有余数，你拿走余数，剩下的就是刚好分好组的了，对手拿 4 - i 个，你就拿 i 个。这样一组一组的拿完，你是最后一个拿完的，所以你是赢家。但是没有余数的话，就是对手按照这个思路赢了。

```cpp
class Solution {
public:
    bool canWinNim(int n) {
        return n % 4 != 0;
    }
};
```

#### 动态规划

按照动态规划的思路，有两个状态，谁先手和石头的数量。因为 n 很大，会超时。

```cpp
class Solution {
public:
    bool canWinNim(int n) {
        bool dp[n + 1][2]; 
        // dp[i][0] 表示还剩 i 个石头， alice 先手
        // dp[i][1] 表示还剩 i 个石头， bob 先手
        for (int i = 1; i <= 3; i++) {
            dp[i][0] = true;
            dp[i][1] = true;
        }
        for (int i = 4; i <= n; i++) {
            /* 
            !dp[i - 1][1] 表示 bob 没赢，即 alice 赢
            !dp[i - 1][0] 表示 alice 没赢，即 bob 赢
            */
            dp[i][0] = !dp[i - 1][1] || !dp[i - 2][1] || !dp[i - 3][1];
            dp[i][1] = !dp[i - 1][0] || !dp[i - 2][0] || !dp[i - 3][0];
            /*
            另一种写法
            如果三种可能性你都赢（取并还是true），那么我输（取反），否则就是我赢的呗
            dp[i][0] = !(dp[i - 1][1] && dp[i - 2][1] && dp[i - 3][1]);
            dp[i][1] = !(dp[i - 1][0] && dp[i - 2][0] && dp[i - 3][0]);
            */
        }
        return dp[n][0];
    }
};
```

