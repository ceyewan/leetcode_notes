### 目录

[TOC]

### 说明

因为比较多动态规划的题目我都做过了，再用C语言写一遍也没什么意思，不如就用python写，一方面是跳出自己的舒适圈，另一方面也是因为动态规划用到的数据结构很简单，可以写。

动态规划该怎么去思考，地哥写的很清楚了，[传送门](https://www.iamshuaidi.com/275.html)。

>动态规划，无非就是利用**历史记录**，来避免我们的重复计算。而这些**历史记录**，我们得需要一些**变量**来保存，一般是用**一维数组**或者**二维数组**来保存。下面我们先来讲下做动态规划题很重要的三个步骤：
>
>- **第一步骤**：定义**数组元素的含义**，上面说了，我们会用一个数组，来保存历史数组，假设用一维数组 dp[] 吧。这个时候有一个非常非常重要的点，就是规定你这个数组元素的含义，例如你的 dp[i] 是代表什么意思？
>
>- **第二步骤**：找出**数组元素之间的关系式**，我觉得动态规划，还是有一点类似于我们高中学习时的**归纳法**的，当我们要计算 dp[n] 时，是可以利用 dp[n-1]，dp[n-2]…..dp[1]，来推出 dp[n] 的，也就是可以利用**历史数据**来推出新的元素值，所以我们要找出数组元素之间的关系式，例如 dp[n] = dp[n-1] + dp[n-2]，这个就是他们的关系式了。而这一步，也是最难的一步，后面我会讲几种类型的题来说。
>
>- **第三步骤**：找出**初始值**。学过**数学归纳法**的都知道，虽然我们知道了数组元素之间的关系式，例如 dp[n] = dp[n-1] + dp[n-2]，我们可以通过 dp[n-1] 和 dp[n-2] 来计算 dp[n]，但是，我们得知道初始值啊，例如一直推下去的话，会由 dp[3] = dp[2] + dp[1]。而 dp[2] 和 dp[1] 是不能再分解的了，所以我们必须要能够直接获得 dp[2] 和 dp[1] 的值，而这，就是**所谓的初始值**。
>
>有了**初始值**，并且有了**数组元素之间的关系式**，那么我们就可以得到 dp[n] 的值了，而 dp[n] 的含义是由你来定义的，你想**求什么，就定义它是什么**，这样，这道题也就解出来了。

### 5、最长回文子串

>给你一个字符串 `s`，找到 `s` 中最长的回文子串。
>
>```
>示例 ：
>
>输入：s = "babad"
>输出："bab"
>解释："aba" 同样是符合题意的答案。
>
>输入：s = "cbbd"
>输出："bb"
>
>输入：s = "a"
>输出："a"
>
>输入：s = "ac"
>输出："a"
>```
>
>
>提示：
>
>- 1 <= `s.length` <= 1000
>- `s` 仅由数字和英文字母（大写和/或小写）组成

我们用 `dp[i][j]` 表示第 `i` 个字母到第 `j` 个字母是回文串。

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        m = len(s)
        ans = s[0:1]	# 答案
        max_length = 0	# 答案长度
        # dp[i][j] = 1表示第i个字母到第j个字母是回文串
        dp = [[0] * m for i in range(m)]
        for i in range(m):
            # 长度为1一定是回文
            dp[i][i] = 1
            # 长度为2
            if i < m - 1 and s[i] == s[i + 1]:
                dp[i][i + 1] = 1
                # 更新长度为2的答案
                if max_length < 2:
                    max_length = 2
                    ans = s[i:i+2]
        # 循环长度length
        for length in range(3, m + 1):
            # i表示左端点，j表示右端点
            for i in range(m):
                j = i + length - 1
                # continue也行，不过后面的j肯定都是不合理的了，所以直接break
                if j >= m:
                    break
                if s[i] == s[j]:
                    # 两端相等，就看中间是不是相等了
                    dp[i][j] = dp[i + 1][j - 1]
                    # 更新答案
                    if dp[i][j] == 1 and max_length < length:
                        max_length = length
                        ans = s[i:j + 1] 
        return ans
```

### 10、正则表达式匹配

>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。
>
>- '.' 匹配任意单个字符
>- '*' 匹配零个或多个前面的那一个元素
>
>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。
>
>```
>示例 1：
>
>输入：s = "aa" p = "a"
>输出：false
>解释："a" 无法匹配 "aa" 整个字符串。
>
>输入：s = "aa" p = "a*"
>输出：true
>解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
>
>输入：s = "ab" p = ".*"
>输出：true
>解释：".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
>
>输入：s = "aab" p = "c*a*b"
>输出：true
>解释：因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。
>
>输入：s = "mississippi" p = "mis*is*p*."
>输出：false
>```
>
>
>提示：
>
>- 1 <= s.length <= 20
>- 1 <= p.length <= 30
>- s 可能为空，且只包含从 a-z 的小写字母。
>- p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。
>- 保证每次出现字符 * 时，前面都匹配到有效的字符

`dp[i][j]` 表示字符串 `s` 长度为 `i` ，字符串 `p` 长度为 `j`  时二者是否匹配

```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        m, n = len(s), len(p)
        # 初始化为都是不匹配的
        dp = [[False] * (n + 1) for i in range(m + 1)]
        # 两个长度为0的时候是匹配的
        dp[0][0] = True
        # dp[0][1]不用考虑，一定时False
        # p长度为0，s 长度不为0，一定是False
        # s长度为0，p不为0，只能当*消除前一个字符才有机会
        for j in range(2, n + 1):
            if p[j - 1] == '*':
                dp[0][j] = dp[0][j - 2]
        # 边界考虑好了，就从长度为 1 开始考虑    
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                # 如果最后面的字符匹配，那么就不用考虑这两个字符了
                if p[j - 1] == '.' or p[j - 1] == s[i - 1]:
                    dp[i][j] = dp[i - 1][j - 1]
                # 最后两个字符不匹配，p最后如果是*号，还有救
                elif p[j - 1] == '*':
                    # *前面的字符和s不匹配，那么就让*干掉前面的那个，还有救
                    # j != 1是为了防止越界，不过既然p[j - 1] == '*'了，那么j肯定!=1
                    if j != 1 and p[j - 2] != '.' and p[j - 2] != s[i - 1]:
                        dp[i][j] = dp[i][j - 2]
                    # *前面的字符和s匹配,那么*可以表示重复0次，重复1次，重复多次
                    # 重复0次，那就干掉*和前面的字符呗，就是dp[i][j - 2]
                    # 重复1次，那就干掉*呗，dp[i][j - 1]或者dp[i - 1][j - 2],两个是一样的，因为我们的前提就是*前面的字符和s匹配
                    # 重复n次，我们就干掉s最后一个，然后*还能重复n-1次，即为dp[i - 1][j]
                    else:
                        dp[i][j] = dp[i - 1][j] or dp[i][j - 1] or dp[i][j - 2]
           		# else 不匹配还不是星号，False呗，不过不用写         
        return dp[m][n]
```

### 22、括号生成

>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。
>
>有效括号组合需满足：左括号必须以正确的顺序闭合。
>
>```
>示例 1：
>
>输入：n = 3
>输出：["((()))","(()())","(())()","()(())","()()()"]
>示例 2：
>
>输入：n = 1
>输出：["()"]
>```
>
>
>提示：
>
>- 1 <= n <= 8

很容易想到，当 `n - 1` 组括号匹配好了之后，第 `n` 组括号可以把它们括起来，也可以放在它们左边，也可以放在它们右边。但是，可不可以从中间把那 `n - 1` 组括号分开呢？可以的。分成 `q` 组和 `n - q - 1` 组匹配好的括号。那么总的来看，就是 `（[q对括号]）[n-1-q对括号]` 或者 `[q对括号]（[n-1-q对括号]）` 。不是的，我们把后面的 `[n-1-q对括号]` 又可以看成 `n - q` 对括号，然后前面再拆开一组括号出来，又重复了。所以：

只有 `([q对括号])[n-1-q对括号]` 这一种可能。

```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        # total[i]就是i对括号所有可能情况的一个列表
        total = []
        # q可以是0，所以用个None代替，最后换成“”即可
        total.append([None])
        total.append(["()"])
        # 确定i对括号
        for i in range(2, n + 1):
            L = []
            # j 对括号
            for j in range(i):
                # j对括号可能的情况
                for str1 in total[j]:
                    # i - j - 1对括号可能的情况
                    for str2 in total[i - j - 1]:
                        if str1 == None:
                            str1 = ""
                        if str2 == None:
                            str2 = ""
                        ans = "(" + str1 + ")" + str2
                        # 把一种可能的情况加入i对括号的可能匹配列表中
                        L.append(ans)
            # 把i对可能匹配括号加入答案列表中            
            total.append(L)
        return total[n]
```

### 32、最长有效括号

>给你一个只包含 `(` 和 `)` 的字符串，找出最长有效（格式正确且连续）括号子串的长度。
>
>```
>示例：
>
>输入：s = "(()"
>输出：2
>解释：最长有效括号子串是 "()"
>
>输入：s = ")()())"
>输出：4
>解释：最长有效括号子串是 "()()"
>
>输入：s = ""
>输出：0
>```
>
>
>提示：
>
>- 0 <= s.length <= 3 * 10^4
>- s[i] 为 '(' 或 ')'

代码可以写的再漂亮些，不过没必要。`dp[i]` 表示以第 `i` 个字符结果的最长有效括号。

```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        if len(s) <= 1:
            return 0
        dp = [0] * len(s)
        ans = 0
        # 确定边界条件，写麻烦一点问题不大，方便看懂就好
        dp[0] = 0
        if s[1] == ')' and s[0] == '(':
            dp[1] = 2
            ans = max(ans, dp[1])
        else:
            dp[1] = 0
        for i in range(2, len(s)):
            # 有效括号一定是）结尾，所以（结尾的一定是0，也可以不写，初始化了
            if s[i] == '(':
                dp[i] = 0
            # s[i] == ')'
            else:
                # 匹配，那么就这两个匹配加上前面匹配的
                if s[i - 1] == '(':
                    dp[i] = dp[i - 2] + 2
                    ans = max(ans, dp[i])
                # s[i - 1] == ')',那么就减去这个括号的匹配长度
                else:
                    # 防止越界
                    if i - 1 - dp[i - 1] >= 0 and s[i - 1 - dp[i - 1]] == '(':
                        # 这种情况是 【括号匹配】（【括号匹配】）
                        if i - 1 - dp[i - 1] > 0:
                            dp[i] = 2 + dp[i - 1] + dp[i - 2 - dp[i - 1]]
                            ans = max(ans, dp[i])
                        # 这种情况是（【括号匹配】）
                        else:
                            dp[i] = 2 + dp[i - 1]
                            ans = max(ans, dp[i])
                    else:
                        dp[i] = 0
        return ans
```

### 42、接雨水

>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
>
>![img](https://gitee.com/ceyewan/pic/raw/master/images/rainwatertrap.png)
>
>```
>示例 ：
>
>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
>输出：6
>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
>
>输入：height = [4,2,0,3,2,5]
>输出：9
>```
>
>提示：
>
>- n == `height.length`
>- 1 <= n <= 2 * 104
>- 0 <= height[i] <= 105

对于柱子 `i`，下雨后水能到达的最大高度等于柱子 `i` 两边的最大高度的最小值，柱子 `i` 处能接的雨水量等于柱子 `i` 处的水能到达的最大高度减去 `height[i]` 。

但是每次都要找到两边最高的柱子，挺做无用功的，所以我们可以利用动态规划，记录下来。`left[i]` 表示下标 `i` 左边的最高的柱子，`right[i]` 表示下标 `i` 右边最高的柱子。

```python
class Solution:
    def trap(self, height: List[int]) -> int:
        length = len(height)
        left = [0 for i in range(length)]
        right = [0 for i in range(length)]
        for i in range(1, length):
            left[i] = max(left[i - 1], height[i - 1])
        for i in range(length - 2, -1, -1):
            right[i] = max(right[i + 1], height[i + 1])
        sum = 0
        for i in range(length):
            # 最小也不能0
            sum += max(0, min(left[i], right[i]) - height[i])
        return sum
```

### 44、通配符匹配

>给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。
>
>- '?' 可以匹配任何单个字符。
>- '*' 可以匹配任意字符串（包括空字符串）。
>- 两个字符串完全匹配才算匹配成功。
>
>说明:
>
>- s 可能为空，且只包含从 a-z 的小写字母。
>
>- p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。
>
>```
>示例:
>
>输入:
>s = "aa"
>p = "a"
>输出: false
>解释: "a" 无法匹配 "aa" 整个字符串。
>
>输入:
>s = "aa"
>p = "*"
>输出: true
>解释: '*' 可以匹配任意字符串。
>
>输入:
>s = "cb"
>p = "?a"
>输出: false
>解释: '?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。
>
>输入:
>s = "adceb"
>p = "*a*b"
>输出: true
>解释: 第一个 '*' 可以匹配空字符串, 第二个 '*' 可以匹配字符串 "dce".
>
>输入:
>s = "acdcb"
>p = "a*c?b"
>输出: false
>```

无他，唯手熟尔。和前面那个正则表达式匹配差不多。`dp[i][j]` 表示长度分别为 `i` 和 `j` 的时候是否匹配。

```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        m, n = len(s), len(p)
        dp = [[False] * (n + 1) for i in range(m + 1)]
        dp[0][0] = True
		# s长度为0，p长度不为0，还有救，只要p是*，匹配空串即可
        for j in range(1, n + 1):
            if p[j - 1] == '*':
                dp[0][j] = dp[0][j - 1]
        # p长度为0，s长度不为0.一定是False，不用写
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                # 最后的字符匹配
                if p[j - 1] == '?' or p[j - 1] == s[i - 1]:
                    dp[i][j] = dp[i - 1][j - 1]
                # 最后的字符不匹配
                else:
                    # p结尾是*，还有救
                    # *匹配空串，则dp[i][j] = dp[i][j - 1]
                    # *匹配一个字符，则dp[i][j] = dp[i - 1][j - 1]
                    # *匹配n个字符，则匹配掉s一个字符后，*还留着，即dp[i][j] = dp[i - 1][j]
                    if p[j - 1] == '*':
                        dp[i][j] = dp[i][j - 1] or dp[i - 1][j - 1] or dp[i - 1][j]
        return dp[m][n]
```

### 45、跳跃游戏Ⅱ

>给你一个非负整数数组 `nums` ，你最初位于数组的第一个位置。
>
>数组中的每个元素代表你在该位置可以跳跃的最大长度。
>
>你的目标是使用最少的跳跃次数到达数组的最后一个位置。
>
>假设你总是可以到达数组的最后一个位置。
>
>```
>示例 :
>
>输入: nums = [2,3,1,1,4]
>输出: 2
>解释: 跳到最后一个位置的最小跳跃数是 2。
>     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
>
>输入: nums = [2,3,0,1,4]
>输出: 2
>```
>
>提示:
>
>- 1 <= `nums.length` <= 10^4
>- 0 <= `nums[i]` <= 1000

`dp[i]` 表示到下标为 `i` 的位置需要的最少步数

```python
class Solution:
    def jump(self, nums: List[int]) -> int:
        length = len(nums)
        # dp[i]表示到下标为i的位置需要的最少步数，初始化为一个较大的数
        dp = [10000] * length
        dp[0] = 0
        for i in range(1, length):
            for j in range(i):
                if j + nums[j] >= i:
                    dp[i] = min(dp[i], dp[j] + 1)
        return dp[length - 1]
```

### 53、最大子序和

>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
>
>```
>示例 1：
>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
>输出：6
>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
>
>输入：nums = [1]
>输出：1
>
>输入：nums = [0]
>输出：0
>
>输入：nums = [-1]
>输出：-1
>
>输入：nums = [-100000]
>输出：-100000
>```
>
>
>提示：
>
>- 1 <= nums.length <= 10^5
>- -10^4 <= nums[i] <= 10^4

`dp[i]` 表示以下标 `i` 结尾的最大子序和

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        my_max = nums[0]
        dp = [0] * len(nums)
        dp[0] = nums[0]
        for i in range(1, len(nums)):
            dp[i] = max(nums[i], dp[i - 1] + nums[i])
            my_max = max(my_max, dp[i])
        return my_max
```

### 55、跳跃游戏

>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。
>
>数组中的每个元素代表你在该位置可以跳跃的最大长度。
>
>判断你是否能够到达最后一个下标。
>
>```
>示例：
>
>输入：nums = [2,3,1,1,4]
>输出：true
>解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
>
>输入：nums = [3,2,1,0,4]
>输出：false
>解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
>```
>
>
>提示：
>
>- 1 <= nums.length <= 3 * 10^4
>- 0 <= nums[i] <= 10^5

`dp[i]` 表示下标为 `i` 能否到达。如果总是这样循环的话，做了很多无用功，比如第一个数就把后面都标记为 `True` 了，那就没必要了。这个做法超时了，这个 `python` 就是逊啦。

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        dp = [False] * len(nums)
        dp[0] = True
        for i in range(len(nums)):
            if dp[i] == True:
                n = min(i + nums[i] + 1, len(nums))
                for j in range(i + 1, n):
                    dp[j] = True
        return dp[len(nums) - 1]
```

我们用 `dp[i]` 表示考虑到下标 `i` 最远能到达的地方。

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        dp = [0] * len(nums)
        dp[0] = nums[0]
        for i in range(1, len(nums)):
            # 可以到达下标 i
            if dp[i - 1] >= i:
                dp[i] = max(dp[i - 1], i + nums[i])
            # 走不到 i 就说明不能再继续往后走了
            else:
                return False
        return True
```

### 62、不同路径

>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
>
>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
>
>问总共有多少条不同的路径？
>
>![img](https://gitee.com/ceyewan/pic/raw/master/images/robot_maze.png)
>
>```
>示例 1：
>
>
>输入：m = 3, n = 7
>输出：28
>
>输入：m = 3, n = 2
>输出：3
>解释：
>从左上角开始，总共有 3 条路径可以到达右下角。
>
>1. 向右 -> 向下 -> 向下
>2. 向下 -> 向下 -> 向右
>3. 向下 -> 向右 -> 向下
>
>输入：m = 7, n = 3
>输出：28
>
>输入：m = 3, n = 3
>输出：6
>```
>
>
>提示：
>
>- 1 <= m, n <= 100
>- 题目数据保证答案小于等于 2 * 10^9

`dp[i][j]` 表示到达坐标 `(i, j)` 的路径数量

```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        dp = [[0] * n for i in range(m)]
        for i in range(m):
            for j in range(n):
                if i == 0 or j == 0:
                    dp[i][j] = 1
                else:
                    # 要么从左边走过来, 要么从右边走过来
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        return dp[m - 1][n - 1] 
```

### 63、不同路径Ⅱ

>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
>
>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
>
>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？
>
>![img](https://gitee.com/ceyewan/pic/raw/master/images/robot_maze.png)
>
>网格中的障碍物和空位置分别用 1 和 0 来表示。
>
>```
>示例 1：
>
>输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
>输出：2
>解释：
>3x3 网格的正中间有一个障碍物。
>从左上角到右下角一共有 2 条不同的路径：
>
>1. 向右 -> 向右 -> 向下 -> 向下
>2. 向下 -> 向下 -> 向右 -> 向右
>
>输入：obstacleGrid = [[0,1],[0,0]]
>输出：1
>```
>
>
>提示：
>
>- m == obstacleGrid.length
>- n == obstacleGrid[i].length
>- 1 <= m, n <= 100
>- `obstacleGrid[i][j]` 为 0 或 1

无它，多考虑点情况罢了

```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        m, n = len(obstacleGrid), len(obstacleGrid[0])
        if obstacleGrid[0][0] == 1:
            return 0
        dp = [[0] * n for i in range(m)]
        for i in range(m):
            for j in range(n):
                if i == 0 and j == 0:
                    dp[i][j] = 1
                elif obstacleGrid[i][j] == 1:
                    dp[i][j] = 0
                elif i == 0:
                    dp[0][j] = dp[0][j - 1]
                elif j == 0:
                    dp[i][0] = dp[i - 1][0]
                else:
                    dp[i][j] = dp[i][j - 1] + dp[i - 1][j]
        return dp[m - 1][n - 1]
```

### 64、最小路径和

>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
>
>说明：每次只能向下或者向右移动一步。
>
>![img](https://gitee.com/ceyewan/pic/raw/master/images/minpath.jpg)
>
>```
>示例：
>
>输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
>输出：7
>解释：因为路径 1→3→1→1→1 的总和最小。
>
>输入：grid = [[1,2,3],[4,5,6]]
>输出：12
>```
>
>
>提示：
>
>m == grid.length
>n == grid[i].length
>1 <= m, n <= 200
>0 <= `grid[i][j]` <= 100

`dp[i][j]` 表示到达坐标 `(i, j)` 的最小路径总和

```python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        dp = [[0] * n for i in range(m)]
        for i in range(m):
            for j in range(n):
                if i == 0 and j == 0:
                    dp[i][j] = grid[i][j]
                elif i == 0:
                    dp[0][j] = dp[0][j - 1] + grid[0][j]
                elif j == 0:
                    dp[i][0] = dp[i - 1][0] + grid[i][0]
                else:
                    dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j]
        return dp[m - 1][n - 1]
```

### 70、爬楼梯

>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
>
>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
>
>注意：给定 n 是一个正整数。
>
>```
>示例：
>
>输入： 2
>输出： 2
>解释： 有两种方法可以爬到楼顶。
>    1.  1 阶 + 1 阶
>  2.  2 阶
>
>    输入： 3
>  输出： 3
>  解释： 有三种方法可以爬到楼顶。
>  1.  1 阶 + 1 阶 + 1 阶
>    2.  1 阶 + 2 阶
>  3.  2 阶 + 1 阶
>```
>

`dp[i]` 表示到达第 `i` 阶台阶的方法数量

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        if n == 1:
            return 1
        dp = [0] * (n + 1)
        dp[1] = 1
        dp[2] = 2
        for i in range(3, n + 1):
            dp[i] = dp[i - 1] + dp[i - 2]
        return dp[n]
```

### 72、编辑距离

>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。
>
>你可以对一个单词进行如下三种操作：
>
>- 插入一个字符
>- 删除一个字符
>- 替换一个字符
>
>```
>示例：
>
>输入：word1 = "horse", word2 = "ros"
>输出：3
>解释：
>horse -> rorse (将 'h' 替换为 'r')
>rorse -> rose (删除 'r')
>rose -> ros (删除 'e')
>
>输入：word1 = "intention", word2 = "execution"
>输出：5
>解释：
>intention -> inention (删除 't')
>inention -> enention (将 'i' 替换为 'e')
>enention -> exention (将 'n' 替换为 'x')
>exention -> exection (将 'n' 替换为 'c')
>exection -> execution (插入 'u')
>```
>
>
>提示：
>
>- 0 <= word1.length, word2.length <= 500
>- word1 和 word2 由小写英文字母组成

注意：字符串 1 增加和字符串 2 减少是一样的，字符串 2 增加和字符串 1 减少是一样的，字符串 1 替换和字符串 2 替换是一样的

`dp[i][j]` 表示两个字符串长度分别是 `i` 和 `j` 时需要的操作次数

```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        m, n = len(word1), len(word2)
        dp = [[0] * (n + 1) for i in range(m + 1)]
        for i in range(m + 1):
            for j in range(n + 1):
                # 其实可以和下面一种合并
                if i == 0 and j == 0:
                    dp[i][j] = 0
                # 一个长度是0，那么就要删去另一个的长度，需要的步骤是 (i + j)
                elif i == 0 or j == 0:
                    dp[i][j] = i + j
                else:
                    # 最后字符串相等，就匹配
                    if word1[i - 1] == word2[j - 1]:
                        dp[i][j] = dp[i - 1][j - 1]
                    # 不相等，那么就要么替换成相等，即dp[i][j] = dp[i - 1][j - 1] + 1
                    # 要么删除字符串1的最后一个字符，即dp[i][j] = dp[i - 1][j] + 1
                    # 要么删除字符串2的最后一个字符，即dp[i][j] = dp[i][j - 1] + 1
                    # 取最小值,注意,不是说删除就一定删除短的那个字符哦
                    else:
                        dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1
        return dp[m][n]
```

### 85、最大矩形

>给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。
>
>![img](https://gitee.com/ceyewan/pic/raw/master/images/maximal.jpg)
>
>```
>示例：
>
>输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
>输出：6
>解释：最大矩形如上图所示。
>
>输入：matrix = []
>输出：0
>
>输入：matrix = [["0"]]
>输出：0
>
>输入：matrix = [["1"]]
>输出：1
>
>输入：matrix = [["0","0"]]
>输出：0
>```
>
>
>提示：
>
>- rows == matrix.length
>- cols == matrix[0].length
>- 0 <= row, cols <= 200
>- `matrix[i][j]` 为 '0' 或 '1'

我们用 `dp[i][j]` 表示以坐标 `(i, j)` 结尾的一行中 1 的长度，即矩形的宽。

```python
class Solution:
    def maximalRectangle(self, matrix: List[List[str]]) -> int:
        if len(matrix) == 0:
            return 0
        m, n = len(matrix), len(matrix[0])
        # 求出dp数组
        dp = [[0] * n for i in range(m)]
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == "1":
                    if j == 0:
                        dp[i][j] = 1
                    else:
                        dp[i][j] = dp[i][j - 1] + 1
        # length 表示矩形的宽，area表示最大面积
        length, area = 0, 0
        for i in range(m):
            for j in range(n):
                # 以坐标(i, j)为右下角的矩形
                if matrix[i][j] == "1":
                    # 高为1的时候
                    length = dp[i][j]
                    area = max(area, length)
                    # 往上探索高度，然后改变宽，求面积
                    for k in range(i - 1, -1, -1):
                        if matrix[k][j] == "0":
                            break
                        else:
                            length = min(length, dp[k][j])
                            area = max(area, length * (i - k + 1))
        return area
```

### 87、扰乱字符串

>使用下面描述的算法可以扰乱字符串 s 得到字符串 t ：
>如果字符串的长度为 1 ，算法停止
>如果字符串的长度 > 1 ，执行下述步骤：
>
>- 在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串 s ，则可以将其分成两个子字符串 x 和 y ，且满足 s = x + y 。
>- 随机 决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，s 可能是 s = x + y 或者 s = y + x 。
>- 在 x 和 y 这两个子字符串上继续从步骤 1 开始递归执行此算法。
>
>给你两个 长度相等 的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串。如果是，返回 true ；否则，返回 false 。
>
>```
>示例：
>
>输入：s1 = "great", s2 = "rgeat"
>输出：true
>解释：s1 上可能发生的一种情形是：
>"great" --> "gr/eat" // 在一个随机下标处分割得到两个子字符串
>"gr/eat" --> "gr/eat" // 随机决定：「保持这两个子字符串的顺序不变」
>"gr/eat" --> "g/r / e/at" // 在子字符串上递归执行此算法。两个子字符串分别在随机下标处进行一轮分割
>"g/r / e/at" --> "r/g / e/at" // 随机决定：第一组「交换两个子字符串」，第二组「保持这两个子字符串的顺序不变」
>"r/g / e/at" --> "r/g / e/ a/t" // 继续递归执行此算法，将 "at" 分割得到 "a/t"
>"r/g / e/ a/t" --> "r/g / e/ a/t" // 随机决定：「保持这两个子字符串的顺序不变」
>算法终止，结果字符串和 s2 相同，都是 "rgeat"
>这是一种能够扰乱 s1 得到 s2 的情形，可以认为 s2 是 s1 的扰乱字符串，返回 true
>
>输入：s1 = "abcde", s2 = "caebd"
>输出：false
>
>输入：s1 = "a", s2 = "a"
>输出：true
>```
>
>
>提示：
>
>- s1.length == s2.length
>- 1 <= s1.length <= 30
>- s1 和 s2 由小写英文字母组成

我们把第一个字符串切开，要么第二个字符串和它一样切，要么互补切。两种只要有一种满足条件就 ok 了。

记忆化搜索，这里讲一下我浅薄的理解，比如说斐波拉契亚数列。

递归的话， 自顶向下。`f(10) = f(9) + f(8)`， `f(9) = f(8) + f(7)` 。这里 `f(8)` 就被计算了两个，时间复杂度很高。

动态规划的话，自底向上。有些时候比较好写，但是有些时候确实很难写。比如说这个题。

记忆化搜索，就像递归一样，自顶向下，很容易理解。但是嘞，每次算一个，就记录下来，这样算过的就不会重复计算了。比如说上面计算过 `f(8)` 了，下次再需要 `f(8)` 就可以直接拿来用。

```python
class Solution:
    def isScramble(self, s1: str, s2: str) -> bool:
        @cache # 语法糖，在缓存中记录下结果
        def dfs(i1: int, i2: int, length : int) -> bool:
            if s1[i1:i1+length] == s2[i2:i2+length]:
                return True
            if Counter(s1[i1:i1+length]) != Counter(s2[i2:i2+length]):
                return False
            for i in range(1, length):
                if dfs(i1, i2, i) and dfs(i1 + i, i2 + i, length - i):
                    return True
                if dfs(i1, i2 + length - i, i) and dfs(i1 + i, i2, length - i):
                    return True
            return False
        ans = dfs(0, 0, len(s1))
        # 最后，清理缓存
        dfs.cache_clear()
        return ans
```

有了上面这个东西，我们就能写出我们的动态规划算法了，你记录我们也记录不就好了。下面 `dp` 一定要用 1 和 -1 表示，用 `True` 和 `False` 会出问题，因为 `False == 0` 。

```python
class Solution:
    def isScramble(self, s1: str, s2: str) -> bool:
        m = len(s1)
        dp = [[[0] * (m + 1) for i in range(m)] for i in range(m)]
        def dfs(i1: int, i2: int, length : int) -> bool:
            if dp[i1][i2][length] != 0:
                return dp[i1][i2][length] > 0
            if s1[i1:i1+length] == s2[i2:i2+length]:
                dp[i1][i2][length] = 1
                return True
            # C语言的话用哈希表统计，因为只有26个英文小写字母
            # 可以用一个统计数组第一个加，第二个减，看是否刚刚好
            if Counter(s1[i1:i1+length]) != Counter(s2[i2:i2+length]):
                dp[i1][i2][length] = -1
                return False
            for i in range(1, length):
                if dfs(i1, i2, i) and dfs(i1 + i, i2 + i, length - i):
                    dp[i1][i2][length] = 1
                    return True
                if dfs(i1, i2 + length - i, i) and dfs(i1 + i, i2, length - i):
                    dp[i1][i2][length] = 1
                    return True
            dp[i1][i2][length] = -1
            return False
        ans = dfs(0, 0, len(s1))
        return ans
```

如果想用传统的 `dp` 自底向上编写太难了，也没必要，这样不香吗？

### 91、解码方法

>一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：
>
>```
>'A' -> 1
>'B' -> 2
>...
>'Z' -> 26
>```
>
>要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为：
>
>"AAJF" ，将消息分组为 (1 1 10 6)
>"KJF" ，将消息分组为 (11 10 6)
>注意，消息不能分组为  (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。
>
>给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。
>
>题目数据保证答案肯定是一个 32 位 的整数。
>
>```
>示例：
>
>输入：s = "12"
>输出：2
>解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
>
>输入：s = "226"
>输出：3
>解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
>
>输入：s = "0"
>输出：0
>解释：没有字符映射到以 0 开头的数字。
>含有 0 的有效映射是 'J' -> "10" 和 'T'-> "20" 。
>由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。
>
>输入：s = "06"
>输出：0
>解释："06" 不能映射到 "F" ，因为字符串含有前导 0（"6" 和 "06" 在映射中并不等价）。
>```
>
>
>提示：
>
>- 1 <= s.length <= 100
>- s 只包含数字，并且可能包含前导零。

`dp[i]` 表示前 `i` 个字符可能的组合数量

```python
class Solution:
    def numDecodings(self, s: str) -> int:
        n = len(s)
        dp = [0] * (n + 1)
        dp[0] = 1
        # 第一个字符，如果是0就没有，如果是其他就有一个
        if s[0] == '0':
            dp[1] = 0
        else:
            dp[1] = 1
        for i in range(2, n + 1):
            # 为0但是可以和前面的组成10 or 20，那么就必须组合
            if s[i - 1] == '0' and (s[i - 2] == '1' or s[i - 2] == '2'):
                dp[i] = dp[i - 2]
            # 为0但是不能组合，那就没办法了    
            elif s[i - 1] == '0':
                dp[i] = 0
            # 和前面那个组合的和在11-19、21-26，可以合起来考虑，也可以分开考虑
            elif 10 < int(s[i - 2]) * 10 + int(s[i - 1]) <= 26:
                dp[i] = dp[i - 2] + dp[i - 1]
            # 其他，如 89 ，这个9就只能自己组成一个字符，比如 09
            else:
                dp[i] = dp[i - 1]
        return dp[n]
```

### 95、不同二叉搜索树Ⅱ

>给你一个整数 n ，请你生成并返回所有由 n 个节点组成且节点值从 1 到 n 互不相同的不同 二叉搜索树 。可以按 任意顺序 返回答案。
>
> ![img](https://gitee.com/ceyewan/pic/raw/master/images/uniquebstn3.jpg)
>
>```
>示例：
>
>输入：n = 3
>输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]
>
>输入：n = 1
>输出：[[1]]
>```
>
>
>提示：
>
>- 1 <= n <= 8

概念说明：二叉搜索树，左节点的值小于根节点，右节点的值大于根节点

我们其实只要把一个可行二叉树的根节点加入列表就行了，`[1,null,2,null,3]`这种形式是题目的输出。

还是一样，我们先写递归算法。我们选择 `i` 作为根节点，那么 `1` 到 `i - 1` 会在它的左边， `i + 1` 到 `n` 会在它的右边。然后我们这样确定好分开的两个小二叉搜索树。

```python
class Solution:
    def generateTrees(self, n: int) -> List[TreeNode]:
        # 获得所有元素从start到end可行的二叉搜索树的根节点组成的列表
        def generateTrees(start, end) -> List[TreeNode]:
            if start > end:
                return [None]            
            allTrees = []
            for i in range(start, end + 1):  # 枚举可行根节点
                # 获得所有可行的左子树集合
                leftTrees = generateTrees(start, i - 1)                
                # 获得所有可行的右子树集合
                rightTrees = generateTrees(i + 1, end)                
                # 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上
                for l in leftTrees:
                    for r in rightTrees:
                        currTree = TreeNode(i)
                        currTree.left = l
                        currTree.right = r
                        allTrees.append(currTree)            
            return allTrees        
        return generateTrees(1, n) if n else []
```

自顶向下，这样写动态规划不香吗？把数据全部存到 `dp` 数组里面。

```python
class Solution:
    def generateTrees(self, n: int) -> List[TreeNode]:
        dp = [[[1] for i in range(n + 2)] for i in range(n + 2)]
        def generateTrees(start, end):
            if dp[start][end] != [1]:
                return dp[start][end]
            if start > end:
                return [None]            
            allTrees = []
            for i in range(start, end + 1):  # 枚举可行根节点
                # 获得所有可行的左子树集合
                leftTrees = generateTrees(start, i - 1)  
                dp[start][i - 1] = leftTrees              
                # 获得所有可行的右子树集合
                rightTrees = generateTrees(i + 1, end)      
                dp[i + 1][end] = rightTrees          
                # 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上
                for l in leftTrees:
                    for r in rightTrees:
                        currTree = TreeNode(i)
                        currTree.left = l
                        currTree.right = r
                        allTrees.append(currTree)            
            dp[start][end] = allTrees   
            return allTrees   
        generateTrees(1, n)
        return dp[1][n]
```

### 96、不同二叉搜索树

>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。
>
> ![img](https://gitee.com/ceyewan/pic/raw/master/images/uniquebstn3.jpg)
>
>```
>示例：
>
>输入：n = 3
>输出：5
>
>输入：n = 1
>输出：1
>```
>
>
>提示：
>
>- 1 <= n <= 19

因为是二叉搜索树，那么加入我们考虑 4 个节点。所有的数字都应该出现在 4 的左上或者左下。假设有 1 个数在左上，有2个数在左下。而且左上必须是一颗二叉搜索树，左下必须是一颗二叉搜索树。同上，上面一定是连续小的，下面一定是连续大的。

```python
class Solution:
    def numTrees(self, n: int) -> int:
        dp = [0] * (n + 1)
        dp[0] = 1
        dp[1] = 1
        for i in range(2, n + 1):
            for j in range(0, i):
                dp[i] += dp[j] * dp[i - j - 1]
        return dp[n]
```

### 2087、统计农场中肥沃金字塔的数量

>有一个 矩形网格 状的农场，划分为 m 行 n 列的单元格。每个格子要么是 肥沃的 （用 1 表示），要么是 贫瘠 的（用 0 表示）。网格图以外的所有与格子都视为贫瘠的。
>
>农场中的 金字塔 区域定义如下：
>
>- 区域内格子数目 大于 1 且所有格子都是 肥沃的 。
>- 金字塔 顶端 是这个金字塔 最上方 的格子。金字塔的高度是它所覆盖的行数。令 (r, c) 为金字塔的顶端且高度为 h ，那么金字塔区域内包含的任一格子 (i, j) 需满足 r <= i <= r + h - 1 且 c - (i - r) <= j <= c + (i - r) 。
>
>一个 倒金字塔 类似定义如下：
>
>- 区域内格子数目 大于 1 且所有格子都是 肥沃的 。
>- 倒金字塔的 顶端 是这个倒金字塔 最下方 的格子。倒金字塔的高度是它所覆盖的行数。令 (r, c) 为金字塔的顶端且高度为 h ，那么金字塔区域内包含的任一格子 (i, j) 需满足 r - h + 1 <= i <= r 且 c - (r - i) <= j <= c + (r - i) 。
>
>下图展示了部分符合定义和不符合定义的金字塔区域。黑色区域表示肥沃的格子。
>
>![img](https://gitee.com/ceyewan/pic/raw/master/images/image.png)
>
>给你一个下标从 **0** 开始且大小为 `m x n` 的二进制矩阵 `grid` ，它表示农场，请你返回 `grid` 中金字塔和倒金字塔的 **总数目** 。
>
>示例：
>
>![image-20211128205503444](https://gitee.com/ceyewan/pic/raw/master/images/image-20211128205503444.png)
>
>```
>输入：grid = [[1,1,1,1,0],[1,1,1,1,1],[1,1,1,1,1],[0,1,0,0,1]]
>输出：13
>解释：
>有 7 个金字塔区域。上图第二和第三张图中展示了它们中的 3 个。
>有 6 个倒金字塔区域。上图中最后一张图展示了它们中的 2 个。
>所以金字塔区域总数目为 7 + 6 = 13.
>```

动态规划，计算出每个以位置`(i, j)`为顶端的最大的金字塔的高度：

>对于高度定义如下:
>
>- 如果（i， j）是不肥沃的,高度为 -1
>- 如果（i， j）是肥沃的, 但是只有它自己, 高度是0
>- 如果（i， j）是肥沃的并且以它为顶端的最大金字塔有 x 行，那么最大的金字塔的高度为 x - 1。

如果要使得`（i， j）`形成金字塔, 则: 

- 它自己是肥沃的
- 左下是肥沃的
- 正下是肥沃的
- 右下是肥沃的

```python
class Solution:
    def countPyramids(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        dp = [[0] * n for i in range(m)]
        ans = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 0:
                    dp[i][j] = -1
                elif i == 0 or j == 0 or j == n - 1:
                    dp[i][j] = 0
                else:
                    dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i - 1][j + 1]) + 1
                    ans += dp[i][j]
        for i in range(m - 1, -1, -1):
            for j in range(n):
                if grid[i][j] == 0:
                    dp[i][j] = -1
                elif i == m - 1 or j == 0 or j == n - 1:
                    dp[i][j] = 0
                else:
                    dp[i][j] = min(dp[i + 1][j - 1], dp[i + 1][j], dp[i + 1][j + 1]) + 1
                    ans += dp[i][j]
        return ans
```

### 97、交错字符串

>给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错 组成的。
>
>两个字符串 s 和 t 交错 的定义与过程如下，其中每个字符串都会被分割成若干 非空 子字符串：
>
>s = s1 + s2 + ... + sn
>t = t1 + t2 + ... + tm
>|n - m| <= 1
>交错 是 s1 + t1 + s2 + t2 + s3 + t3 + ... 或者 t1 + s1 + t2 + s2 + t3 + s3 + ...
>提示：a + b 意味着字符串 a 和 b 连接。
>
>示例：
>
>![img](https://gitee.com/ceyewan/pic/raw/master/images/interleave.jpg)
>
>```
>输入：s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"
>输出：true
>```

```python
class Solution:
    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:
        m, n, q = len(s1), len(s2), len(s3)
        # 长度不匹配
        if (m + n != q):
            return False
        dp = [[False] * (n + 1) for i in range(m + 1)]
        for i in range(m + 1):
            for j in range(n + 1):
                # 长度都为0
                if i == 0 and j == 0:
                    dp[i][j] = True
                # 一个长度为0，就看另一个是否匹配
                elif i == 0:
                    # dp[0][j] = s2[:j + 1] == s3[:j + 1]
                    # 但是为了体现转移方程，我们下面那样写
                    if s2[j - 1] == s3[j - 1]:
                        dp[0][j] = dp[0][j - 1]
                    else:
                        dp[0][j] = False
                #同上
                elif j == 0:
                    if s1[i - 1] == s3[i - 1]:
                        dp[i][0] = dp[i - 1][0]
                    else:
                        dp[i][0] = False
                # 两个都可以匹配最后一个字符，那就让它们都试一下
                elif s1[i - 1] == s3[i + j - 1] and s2[j - 1] == s3[i + j - 1]:
                    dp[i][j] = dp[i - 1][j] or dp[i][j - 1]
                # s1匹配
                elif s1[i - 1] == s3[i + j - 1]:
                    dp[i][j] = dp[i - 1][j]
                # s2匹配
                elif s2[j - 1] == s3[i + j - 1]:
                    dp[i][j] = dp[i][j - 1]
        return dp[m][n]
```

### 115、不同的子序列

>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。
>
>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，"ACE" 是 "ABCDE" 的一个子序列，而 "AEC" 不是）
>
>题目数据保证答案符合 32 位带符号整数范围。
>
>```
>示例：
>
>输入：s = "rabbbit", t = "rabbit"
>输出：3
>解释：
>如下图所示, 有 3 种可以从 s 中得到 "rabbit" 的方案。
>rabbbit
>rabbbit
>rabbbit
>
>输入：s = "babgbag", t = "bag"
>输出：5
>解释：
>如下图所示, 有 5 种可以从 s 中得到 "bag" 的方案。 
>babgbag
>babgbag
>babgbag
>babgbag
>babgbag
>```
>
>
>提示：
>
>- 0 <= s.length, t.length <= 1000
>- s 和 t 由英文字母组成

```python
class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        m, n = len(s), len(t)
        dp = [[0] * (n + 1) for i in range(m + 1)]
        # dp[i][j]表示s的长度为i，t的长度为j时的方案数
        for i in range(m + 1):
            for j in range(n + 1):
                # 两个长度都是0，匹配
                if i == 0 and j == 0:
                    dp[i][j] = 1
                # 子串比原字符串还长，为0
                elif i < j:
                    dp[i][j] = 0
                # 子串长度为0，说明是刚刚有一个匹配掉了，所以应该方案为1，空的拼在最后
                elif i > 0 and j == 0:
                    dp[i][j] = 1
                # 相等，那么可以匹配，两个都去掉；也可以不匹配，去掉原串的最后一个字符
                elif s[i - 1] == t[j - 1]:
                    dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]
                # 不相等，则原串去掉后面这个字符
                elif s[i - 1] != t[j - 1]:
                    dp[i][j] = dp[i - 1][j]
        return dp[m][n]
```

### 118、杨辉三角

>给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。
>
>在「杨辉三角」中，每个数是它左上方和右上方的数的和。
>
>![img](https://gitee.com/ceyewan/pic/raw/master/images/1626927345-DZmfxB-PascalTriangleAnimated2.gif)
>
>```
>示例:
>
>输入: numRows = 5
>输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
>
>输入: numRows = 1
>输出: [[1]]
>```
>
>
>提示:
>
>- 1 <= numRows <= 30

```python
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        dp = [[1] * numRows for i in range(numRows)]
        ans = [[1] for i in range(numRows)]
        for i in range(1, numRows):
            for j in range(1, i + 1):
                if j < i:
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]
                else:
                    dp[i][j] = dp[i - 1][j - 1]
                ans[i].append(dp[i][j])
        return ans
```

### 119、杨辉三角Ⅱ

>给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。
>
>在「杨辉三角」中，每个数是它左上方和右上方的数的和。
>
>![img](https://gitee.com/ceyewan/pic/raw/master/images/1626927345-DZmfxB-PascalTriangleAnimated2.gif)
>
>```
>示例:
>
>输入: rowIndex = 3
>输出: [1,3,3,1]
>
>输入: rowIndex = 0
>输出: [1]
>
>输入: rowIndex = 1
>输出: [1,1]
>```
>
>
>提示:
>
>- 0 <= rowIndex <= 33
>
>**进阶：**
>
>- 你可以优化你的算法到 `O(rowIndex)` 空间复杂度吗？

小改一下上面的代码就好了，这个进阶也是地总讲过的。不懂？那就去看看地总的文章吧。

```c
class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        dp = [1] * (rowIndex + 1)
        a = 0
        b = 0
        for i in range(1, rowIndex + 1):
            a = 1
            for j in range(1, i + 1):
                if j == i:
                    dp[j] = a
                else:
                    b = dp[j]
                    dp[j] = a + b
                    a = b    
        return dp
```

### 120、三角形最短路径和

>给定一个三角形 triangle ，找出自顶向下的最小路径和。
>
>每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。
>
>```
>示例：
>
>输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
>输出：11
>解释：如下面简图所示：
>      2
>    3 4
>  6 5 7
>4 1 8 3
>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。
>
>输入：triangle = [[-10]]
>输出：-10
>```
>
>
>提示：
>
>- 1 <= triangle.length <= 200
>- triangle[0].length == 1
>- triangle[i].length == triangle[i - 1].length + 1
>- -10^4 <= `triangle[i][j]` <= 10^4
>
>
>进阶：
>
>- 你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题吗？

`dp[i][j]` 表示移动到第 `i` 行的第 `j` 个的路径和

```python
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        m = len(triangle)
        dp = [[0] * m for i in range(m)]
        for i in range(m):
            for j in range(i + 1):
                if i == 0 and j == 0:
                    dp[i][j] = triangle[i][j]
                elif j == 0:
                    dp[i][j] = triangle[i][j] + dp[i - 1][0]
                elif j == i:
                    dp[i][j] = triangle[i][j] + dp[i - 1][j - 1]
                else:
                    dp[i][j] = triangle[i][j] + min(dp[i - 1][j], dp[i - 1][j - 1])
        ans = dp[m - 1][0]
        for i in range(m):
            ans = min(dp[m - 1][i], ans)
        return ans
```

进阶：同上题，我们只需要一个一维数组加两个常数即可。我们求 `dp[i]` 的时候，需要用到 `dp[i]` 和 `dp[i - 1]`，但是这个 `dp[i - 1]` 是上一行的，而不是上一个求出来的，所以需要存起来。求下一个的时候需要用到还未改变的 `dp[i]` ，所以也要存起来。我讲的不清楚，去看地总文章吧。

```python
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        m = len(triangle)
        dp = [triangle[0][0]] * m
        a = 0
        b = 0
        for i in range(1, m):
            for j in range(i + 1):
                if j == 0:
                    a = dp[j]
                    dp[j] = dp[j] + triangle[i][j]
                elif j == i:
                    dp[j] = a + triangle[i][j]
                else:
                    b = dp[j]
                    dp[j] = min(a, dp[j]) + triangle[i][j]
                    a = b
        ans = dp[0]
        for i in range(m):
            ans = min(ans, dp[i])
        return ans
```

### 121、买卖股票的最佳时机

>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
>
>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
>
>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
>
>```
>示例：
>
>输入：[7,1,5,3,6,4]
>输出：5
>解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
>注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
>
>输入：prices = [7,6,4,3,1]
>输出：0
>解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
>```
>
>
>提示：
>
>- 1 <= prices.length <= 10^5
>- 0 <= prices[i] <= 10^4

我本以为是做一道题，没想到却是六道题。既然大佬都诚心诚意写了题解了，我偷学一下也未尝不可。动态规划，玄之又玄。[大佬文章传送门](https://leetcode-cn.com/circle/article/qiAgHn/)。

`dp[i][0]` 表示在第 `i` 天，手上没有股票的收益， `dp[i][1]` 表示在第 `i` 天手上有股票的收益。

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        m = len(prices)
        dp = [[0] * 2 for i in range(m)]
        # 第 0 天不买，即 dp[0][0] = 0
      	# 第 0 天买了，即 dp[0][1] = -prices[0]
        dp[0][1] = -prices[0]
        for i in range(1, m):
            # 第 i 天手上没股票的收益是第 i-1 天手上没股票的收益和
            # 第 i-1 天有股票但是第 i 天卖了的收益的最大值
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])
            # 第 i 天手上有股票的收益是第 i-1 天手上有股票的收益和
            # 第 i-1 天没股票但是第 i 天买了的收益的最大值
            # 因为只能买卖一次，所以第 i-1 天没股票的收益一定是 0 ，可以不写
            dp[i][1] = max(dp[i - 1][1], -prices[i])
        return dp[m - 1][0]
```

### 122、买卖股票的最佳时机Ⅱ

>给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。
>
>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
>
>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
>
>```
>示例:
>
>输入: prices = [7,1,5,3,6,4]
>输出: 7
>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
>随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
>
>输入: prices = [1,2,3,4,5]
>输出: 4
>解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
>注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
>
>输入: prices = [7,6,4,3,1]
>输出: 0
>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
>```
>
>
>提示：
>
>- 1 <= prices.length <= 3 * 10^4
>- 0 <= prices[i] <= 10^4

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        m = len(prices)
        dp = [[0] * 2 for i in range(m)]
        # 第 0 天不买，即 dp[0][0] = 0
      	# 第 0 天买了，即 dp[0][1] = -prices[0]
        dp[0][1] = -prices[0]
        for i in range(1, m):
            # 第 i 天手上没股票的收益是第 i-1 天手上没股票的收益和
            # 第 i-1 天有股票但是第 i 天卖了的收益的最大值
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])
            # 第 i 天手上有股票的收益是第 i-1 天手上有股票的收益和
            # 第 i-1 天没股票但是第 i 天买了的收益的最大值，
            # 因为可以买卖多次，所以第 i-1 天没股票的收益不定，得写上
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])
        return dp[m - 1][0]
```

### 123、买卖股票的最佳时机Ⅲ

>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。
>
>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。
>
>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
>
>```
>示例:
>
>输入：prices = [3,3,5,0,0,3,1,4]
>输出：6
>解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
>随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
>
>输入：prices = [1,2,3,4,5]
>输出：4
>解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
>注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
>因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
>
>输入：prices = [7,6,4,3,1] 
>输出：0 
>解释：在这个情况下, 没有交易完成, 所以最大利润为 0。
>
>输入：prices = [1]
>输出：0
>```
>
>
>提示：
>
>- 1 <= prices.length <= 10^5
>- 0 <= prices[i] <= 10^5

交易 `k` 次，这里我们用买入来算交易，卖出不算。

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        m = len(prices)
        dp = [[[0] * 2 for i in range(3)] for j in range(m)]
        dp[0][1][0] = 0
        dp[0][1][1] = -prices[0]
        dp[0][2][0] = 0
        dp[0][2][1] = -prices[0]
        for i in range(1, m):
            # 前 i 天最多买入两次且手里没有股票可以是前 i-1 天最多买入两次手里没有股票，
            # 或者前 i-1 天买入两次手里有股票然后第 i 天卖掉
            dp[i][2][0] = max(dp[i - 1][2][0], dp[i - 1][2][1] + prices[i])
            # 前 i 天最多买入两次且手里有股票可以是前 i-1 天最多买入两次手里有股票
            # 或者前 i-1 天最多买入一次且手里没有股票然后第 i 天再买入
            dp[i][2][1] = max(dp[i - 1][2][1], dp[i - 1][1][0] - prices[i])
            # 前 i 天最多买入一次且手里没有股票可以是前 i-1 天最多买入一次且手里没有股票
            # 或者前 i-1 天最多买入一次手上留有股票，然后第 i 天卖掉
            dp[i][1][0] = max(dp[i - 1][1][0], dp[i - 1][1][1] + prices[i])
            # 前 i 天最多买入一次且手里有股票可以是前 i-1 天最多买入一次且手里有股票
            # 或者前 i-1 天最多买入0次（就是0），然后第 i 天买入一次
            dp[i][1][1] = max(dp[i - 1][1][1], dp[i - 1][0][0] - prices[i])
        return dp[m - 1][2][0]
```

### 188、买卖股票的最佳时机Ⅳ

>给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。
>
>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。
>
>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
>
>```
>示例：
>
>输入：k = 2, prices = [2,4,1]
>输出：2
>解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
>
>输入：k = 2, prices = [3,2,6,5,0,3]
>输出：7
>解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
>随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。
>```
>
>
>提示：
>
>- 0 <= k <= 100
>- 0 <= prices.length <= 1000
>- 0 <= prices[i] <= 1000
>

- k 大于等于长度的一半时，就相当于不限交易次数，即题目Ⅱ
- k 大于 0 且小于长度的 一半时，相当于题目Ⅲ

```python
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        m = len(prices)
        if m == 0 or k == 0:
            return 0
        # python 整数除用 // 表示
        if k >= m // 2:
            dp = [[0] * 2 for i in range(m)]
            dp[0][1] = -prices[0]
            for i in range(1, m):
                dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])
                dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])
            return dp[m - 1][0]
        dp = [[[0] * 2 for i in range(k + 1)] for j in range(m)]
        # 第 0 天拥有股票，说明买了
        for i in range(1, k + 1):
            dp[0][i][1] = -prices[0]
        for i in range(1, m):
            #  j 从大到小或者从小到大都没有关系，是一样的
            # 因为都只依赖于前一天的，今天的状态之间没有影响
            for j in range(1, k + 1):
                dp[i][j][0] = max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i])
                dp[i][j][1] = max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i])
        return dp[m - 1][k][0]
```

### 309、买卖股票的最佳时机（含冷冻期）

>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。
>
>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:
>
>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
>
>```
>示例:
>
>输入: [1,2,3,0,2]
>输出: 3 
>解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
>```

按照题目Ⅱ，稍作修改。我们在第 `i` 天买入，那么意味着上一次交易最晚最晚是第 `i - 2` 天卖出。

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        m = len(prices)
        dp = [[0] * 2 for i in range(m)]
        # 第 0 天不买，即 dp[0][0] = 0
      	# 第 0 天买了，即 dp[0][1] = -prices[0]
        dp[0][1] = -prices[0]
        for i in range(1, m):
            # 第 i 天手上没股票的收益是第 i-1 天手上没股票的收益和
            # 第 i-1 天有股票但是第 i 天卖了的收益的最大值
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])
            # 第 i 天手上有股票的收益是第 i-1 天手上有股票的收益和
            # 第 i-2 天手上没有股票的第 i 天买入收益
            if i >= 2:
                dp[i][1] = max(dp[i - 1][1], dp[i - 2][0] - prices[i])
            else:
                dp[i][1] = max(dp[i - 1][1], -prices[i])
        return dp[m - 1][0]
```

### 714、买卖股票的最佳时机（含手续费）

>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。
>
>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。
>
>返回获得利润的最大值。
>
>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。
>
>```
>示例：
>
>输入：prices = [1, 3, 2, 8, 4, 9], fee = 2
>输出：8
>解释：能够达到的最大利润:  
>在此处买入 prices[0] = 1
>在此处卖出 prices[3] = 8
>在此处买入 prices[4] = 4
>在此处卖出 prices[5] = 9
>总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8
>
>输入：prices = [1,3,7,5,10,3], fee = 3
>输出：6
>```
>
>
>提示：
>
>- 1 <= prices.length <= 5 * 10^4
>- 1 <= prices[i] < 5 * 10^4
>- 0 <= fee < 5 * 10^4

依照题目Ⅱ，稍作修改。我们只需要在每次买入或者卖出的时候减去手续费就好了。下面是按照卖出时减去手续费写的。

```python
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        m = len(prices)
        dp = [[0] * 2 for i in range(m)]
        # 第 0 天不买，即 dp[0][0] = 0
      	# 第 0 天买了，即 dp[0][1] = -prices[0]
        dp[0][1] = -prices[0]
        for i in range(1, m):
            # 第 i 天手上没股票的收益是第 i-1 天手上没股票的收益和
            # 第 i-1 天有股票但是第 i 天卖了的收益的最大值
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee)
            # 第 i 天手上有股票的收益是第 i-1 天手上有股票的收益和
            # 第 i-1 天没股票但是第 i 天买了的收益的最大值
            # 因为可以买卖多次，所以第 i-1 天没股票的收益不定
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])
        return dp[m - 1][0]
```

### 887、鸡蛋掉落

>给你 k 枚相同的鸡蛋，并可以使用一栋从第 1 层到第 n 层共有 n 层楼的建筑。
>
>已知存在楼层 f ，满足 0 <= f <= n ，任何从 高于 f 的楼层落下的鸡蛋都会碎，从 f 楼层或比它低的楼层落下的鸡蛋都不会破。
>
>每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 x 扔下（满足 1 <= x <= n）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 重复使用 这枚鸡蛋。
>
>请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？
>
>```
>示例：
>
>输入：k = 1, n = 2
>输出：2
>解释：
>鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0 。 
>否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1 。 
>如果它没碎，那么肯定能得出 f = 2 。 
>因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。 
>
>输入：k = 2, n = 6
>输出：3
>
>输入：k = 3, n = 14
>输出：4
>```
>
>
>提示：
>
>- 1 <= k <= 100
>- 1 <= n <= 10^4

参考[李永乐老师的讲解视频](https://www.bilibili.com/video/BV1KE41137PK)，和 `labuladong` 的题解。

状态转移方程：
![image-20211129193250219](https://gitee.com/ceyewan/pic/raw/master/images/image-20211129193250219.png)

我们用 `dp[i][j]`  表示楼层高度为 `i` ，鸡蛋数目为 `j` 要确定楼层高度需要的最少操作次数。

下面的算法我理解了，但是超时了，时间复杂度是 `O(n^2 * k)`

```python
class Solution:
    def superEggDrop(self, k: int, n: int) -> int:
        # 初始化为一个很大的值
        dp = [[10e9] * (k + 1) for i in range(n + 1)]
        for j in range(k + 1):
            # 楼层高度为 0 ，需要次数为 0
            dp[0][j] = 0 
            # 楼层高度为 1 ，需要次数为 1 （只有鸡蛋数目为 0 的时候是 0
            dp[1][j] = 1
        for i in range(n + 1):
            # 鸡蛋数目为 0 ，我们设为 0（实际上并不存在这种情况
            dp[i][0] = 0
            # 鸡蛋数目为 1 ，需要试（最坏情况）的次数是 i 次
            dp[i][1] = i
        for i in range(2, n + 1):
            for j in range(2, k + 1):
                # 我们拿出一个鸡蛋，在第 p 层试一下，碎了就考虑 p-1 层
                # 没碎就考虑上面的 i-p 层
                # 由于不能是碰巧，只能一定。所以取 max
                # p 可以有多种取值，要找出最好的一种，所以取 min
                for p in range(1, i + 1):
                    dp[i][j] = min(dp[i][j], max(dp[p - 1][j - 1], dp[i - p][j]) + 1)
        return dp[n][k]
```

动态规划 + 二分查找。

把最后那个换成二分查找。时间复杂度是 `O(n * logn * k)`，属实给我整不会了，这也能超时。

```python
class Solution:
    def superEggDrop(self, k: int, n: int) -> int:
        dp = [[0] * (k + 1) for i in range(n + 1)]
        # dp[i][j] 表示楼层高度为 i ，鸡蛋数目为 j 需要的次数
        # 楼层高度为 0 ，需要次数为 0
        for j in range(k + 1):
            dp[1][j] = 1
        for i in range(n + 1):
            dp[i][1] = i
        for i in range(2, n + 1):
            for j in range(2, k + 1):
                left = 1
                right = i
                while left < right:
                    mid = left + (right - left + 1) // 2
                    if (dp[mid - 1][j - 1] > dp[i - mid][j]):
                        right = mid - 1
                    else:
                        left = mid
                dp[i][j] = max(dp[left - 1][j - 1], dp[i - left][j]) + 1
        return dp[n][k]
```

方法二：

`dp[k][m]` 的含义是 `k` 个鸡蛋测试 `m` 次最多能够确定多少楼层
当在任一楼层仍下鸡蛋的时候，鸡蛋出现要么碎了，要么没碎这两种情况。
碎了的话就测上面的楼层，上面的楼层数为：`dp[k - 1][m - 1]`，
没碎就测下面的楼层，下面的楼层数为：`dp[k][m - 1]`，最后加上扔下鸡蛋的这一楼层。
所以总的楼层数 `n =  dp[k - 1][m - 1] + dp[k][m - 1] + 1`

递推公式是：
`dp[k][m] = dp[k - 1][m - 1] + dp[k][m - 1] + 1`

```python
class Solution:
    def superEggDrop(self, k, n):
       # dp(k, n)表示楼层的高度
       dp = [[0] * (k + 1) for _ in range(n + 1)]
       m = 0
       while dp[m][k] < n:
           m += 1
           for i in range(1, k+1):
               dp[m][i] = dp[m - 1][i - 1] + 1 + dp[m - 1][i]
       return m
```

### 458、可怜的小猪

>有 buckets 桶液体，其中 正好 有一桶含有毒药，其余装的都是水。它们从外观看起来都一样。为了弄清楚哪只水桶含有毒药，你可以喂一些猪喝，通过观察猪是否会死进行判断。不幸的是，你只有 minutesToTest 分钟时间来确定哪桶液体是有毒的。
>
>喂猪的规则如下：
>
>选择若干活猪进行喂养
>可以允许小猪同时饮用任意数量的桶中的水，并且该过程不需要时间。
>小猪喝完水后，必须有 minutesToDie 分钟的冷却时间。在这段时间里，你只能观察，而不允许继续喂猪。
>过了 minutesToDie 分钟后，所有喝到毒药的猪都会死去，其他所有猪都会活下来。
>重复这一过程，直到时间用完。
>给你桶的数目 buckets ，minutesToDie 和 minutesToTest ，返回在规定时间内判断哪个桶有毒所需的 最小 猪数。
>
>```
>示例：
>
>输入：buckets = 1000, minutesToDie = 15, minutesToTest = 60
>输出：5
>
>输入：buckets = 4, minutesToDie = 15, minutesToTest = 15
>输出：2
>
>输入：buckets = 4, minutesToDie = 15, minutesToTest = 30
>输出：2
>```
>
>
>提示：
>
>- 1 <= buckets <= 1000
>- 1 <= minutesToDie <= minutesToTest <= 100

设 n 只猪在 r 轮喝水之后能够判断 `f(n,r)` 桶水

我们考虑每个桶的情况：

1. 同时被 n 只猪喝，那么假设这桶水有毒，所有猪全死了，如果这类桶数量超过1，显然就无法判断具体是哪一桶了，因此这类桶最多一个(猪全死了就是它有毒)
2. 同时被 n - 1 只猪喝，假设这桶水有毒，死了 n - 1 只猪，那么只剩下一只猪和 r - 1轮喝水机会，那么这类水桶最多只能有 `C(n,n-1) * F(1,r-1)`个
3. 同时被 n - k 只猪喝，假设这桶水有毒，死了 n - k 只猪，那么只剩下 k 只猪和 r - 1 轮喝水机会，那么这类水桶最多只能有 `C(n,k) * F(k,r-1)`个
4. 这一轮没有猪喝，那么假设这桶水有毒，只剩下 n 只猪和 r - 1 轮喝水机会，那么这类桶最多只能有 `C(n,0) * F(n,r-1)`个

第 1 种情况也可以视作 `F(0,r-1)` ，因为如果不给猪的话，最多只能判断一桶水的情况，只剩一桶水时它必有毒，因此得出递推公式：

`F(n,r) = C(n,n) * F(0,r-1) + C(n,n-1) * F(1,r-1) + ... + C(n,0) * F(n,r-1)`

当 i ≥ 1 时，组合数的计算如下：

- `C(i, 0) = C(i, i) = 1`

- 当 0 < j < i 时，`C(i, j) = C(i - 1, j - 1) + C(i - 1, j)`

![image-20211129221544951](https://gitee.com/ceyewan/pic/raw/master/images/image-20211129221544951.png)

以下为官方题解：

```python
class Solution:
    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:
        if buckets == 1:
            return 0
        combinations = [[0] * (buckets + 1) for _ in range(buckets + 1)]
        combinations[0][0] = 1
        iterations = minutesToTest // minutesToDie
        f = [[1] * (iterations + 1)] + [[1] + [0] * iterations for _ in range(buckets - 1)]
        for i in range(1, buckets):
            combinations[i][0] = 1
            for j in range(1, i):
                combinations[i][j] = combinations[i - 1][j - 1] + combinations[i - 1][j]
            combinations[i][i] = 1
            for j in range(1, iterations + 1):
                for k in range(i + 1):
                    f[i][j] += f[k][j - 1] * combinations[i][i - k]
            if f[i][iterations] >= buckets:
                return i
        return 0
```

关于上面的数学推导，还有一个证明，绝了！

![image-20211129222355877](https://gitee.com/ceyewan/pic/raw/master/images/image-20211129222355877.png)

### 124、二叉树中的最大路径和

>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。
>
>路径和 是路径中各节点值的总和。
>
>给你一个二叉树的根节点 root ，返回其 最大路径和 。
>
>```
>示例 1：
>
>输入：root = [1,2,3]
>输出：6
>解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6
>```
>
>![img](https://gitee.com/ceyewan/pic/raw/master/images/exx1.jpg)
>
>```
>示例 2：
>
>输入：root = [-10,9,20,null,null,15,7]
>输出：42
>解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42
>```
>
>![img](https://gitee.com/ceyewan/pic/raw/master/images/exx2.jpg)
>
>提示：
>
>- 树中节点数目范围是 [1, 3 * 10^4]
>- -1000 <= Node.val <= 1000

不愧是我，代码写的是真的丑啊。不过是递归罢了，然后记忆化搜索，最后改成动态规划。

```python
class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        @cache
        def count(root):
            if root == None:
                return [-10e9] * 3
            if root.left == None and root.right == None:
                return [root.val] * 3
            else:
                # 它给别人做左节点能提供的最大路径
                count_left = root.val + max(count(root.left)[0], count(root.left)[1], root.left.val if root.left != None else -10e9)
                # 给别人做右节点能提供的最大路径
                count_right = root.val + max(count(root.right)[0], count(root.right)[1],  root.right.val if root.right != None else -10e9)
                # 它之内的最大路径和
                count_max = max(count_left + count_right - root.val, count_left, count_right, root.val, count(root.right)[2], count(root.left)[2])
                return [count_left, count_right, count_max]
        ans = count(root)[2]
        count.cache_clear()
        return ans
```

看看官方题解，写的就是漂亮。思路是一样的，递归。其实这就是动态规划了，父节点依赖于两个子节点嘛。而且这里两个子节点之间互不冲突，所以没必要用一个 `dp` 数组记录。

```python
class Solution:
    def __init__(self):
        self.maxSum = float("-inf")
    def maxPathSum(self, root: TreeNode) -> int:
        def maxGain(node):
            if not node:
                return 0
            # 递归计算左右子节点的最大贡献值
            # 只有在最大贡献值大于 0 时，才会选取对应子节点
            leftGain = max(maxGain(node.left), 0)
            rightGain = max(maxGain(node.right), 0)            
            # 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值
            priceNewpath = node.val + leftGain + rightGain            
            # 更新答案
            self.maxSum = max(self.maxSum, priceNewpath)
            # 返回节点的最大贡献值
            return node.val + max(leftGain, rightGain)   
        maxGain(root)
        return self.maxSum
```

### 131、分割回文串

>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。
>
>回文串 是正着读和反着读都一样的字符串。
>
>```
>示例：
>
>输入：s = "aab"
>输出：[["a","a","b"],["aa","b"]]
>
>输入：s = "a"
>输出：[["a"]]
>```
>
>
>提示：
>
>- 1 <= s.length <= 16
>
>- s 仅由小写英文字母组成

同第 5 题，找到回文串 `dp` 数组，然后回溯 / `dfs` 组合起来就好了。

```python
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        m = len(s)
        dp = [[0] * (m + 1) for _ in range(m + 1)]
        for i in range(m):
            dp[i][i] = 1
            if i + 1 < m and s[i] == s[i + 1]:
                dp[i][i + 1] = 1
        for L in range(3, m + 1):
            for i in range(0, m):
                j = i + L - 1
                if j >= m:
                    continue
                if s[i] == s[j]:
                    dp[i][j] = dp[i + 1][j - 1]      
        ret = []
        ans = []  
        def dfs(i: int):
            if i == m:
                ret.append(ans[:])
                return 
            for j in range(i, m):
                if dp[i][j]:
                    ans.append(s[i:j+1])
                    dfs(j+1)
                    ans.pop()
        dfs(0)
        return ret
```

### 132、分割回文串Ⅱ

>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文。
>
>返回符合要求的 最少分割次数 。
>
>```
>示例：
>
>输入：s = "aab"
>输出：1
>解释：只需一次分割就可将 s 分割成 ["aa","b"] 这样两个回文子串。
>
>输入：s = "a"
>输出：0
>
>输入：s = "ab"
>输出：1
>```
>
>
>提示：
>
>- 1 <= s.length <= 2000
>- s 仅由小写英文字母组成

我们也可以按照上面的 `dfs`  写，不过会超时。

![image-20211129234507278](https://gitee.com/ceyewan/pic/raw/master/images/image-20211129234507278.png)

`dp1[i][j] = True` 表示从下标 `i` 到下标 `j` 是回文串。

`dp2[i]` 表示下标为 0 到下标为 `i` 的字符串需要的最少切割次数

```python
class Solution:
    def minCut(self, s: str) -> int:
        n = len(s)
        dp1 = [[True] * n for _ in range(n)]
        for i in range(n - 1, -1, -1):
            for j in range(i + 1, n):
                dp1[i][j] = (s[i] == s[j]) and dp1[i + 1][j - 1]
        # 上面得到所有是回文串的切片
        dp2 = [2000] * n
        for i in range(n):
            if dp1[0][i]:
                dp2[i] = 0
            else:
                for j in range(i):
                    if dp1[j + 1][i]:
                        dp2[i] = min(dp2[i], dp2[j] + 1)
        return dp2[n - 1]
```

### 139、单词拆分

>给你一个字符串 s 和一个字符串列表 wordDict 作为字典，判定 s 是否可以由空格拆分为一个或多个在字典中出现的单词。
>
>说明：拆分时可以重复使用字典中的单词。
>
>```
>示例：
>
>输入: s = "leetcode", wordDict = ["leet", "code"]
>输出: true
>解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。
>
>输入: s = "applepenapple", wordDict = ["apple", "pen"]
>输出: true
>解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。
>     注意你可以重复使用字典中的单词。
>
>输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
>输出: false
>```
>
>
>提示：
>
>- 1 <= s.length <= 300
>- 1 <= wordDict.length <= 1000
>- 1 <= wordDict[i].length <= 20
>- s 和 wordDict[i] 仅有小写英文字母组成
>- wordDict 中的所有字符串 互不相同

```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        n = len(s)
        dp = [False] * (n + 1) # dp[i] = True表示s的长度为i时可以拆分
        dp[0] = True 
        for i in range(1, n + 1):
            for j in range(i):
                if s[j:i] in wordDict:
                        dp[i] = dp[i] or dp[j]
        return dp[n]
    # 注意：长度为i对应的下标是i-1
```

### 140、单词拆分Ⅱ

>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。
>
>说明：
>
>- 分隔时可以重复使用字典中的单词。
>- 你可以假设字典中没有重复的单词。
>
>```
>示例：
>
>输入:
>s = "catsanddog"
>wordDict = ["cat", "cats", "and", "sand", "dog"]
>输出:
>[
>  "cats and dog",
>  "cat sand dog"
>]
>
>输入:
>s = "pineapplepenapple"
>wordDict = ["apple", "pen", "applepen", "pine", "pineapple"]
>输出:
>[
>  "pine apple pen apple",
>  "pineapple pen apple",
>  "pine applepen apple"
>]
>解释: 注意你可以重复使用字典中的单词。
>
>输入:
>s = "catsandog"
>wordDict = ["cats", "dog", "sand", "and", "cat"]
>输出:
>[]
>```

记录下所有在字典中的切片，然后 `dfs` 或者说是回溯法获得所有组合。

```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:
        n = len(s)
        dp = [[False] * n for _ in range(n)]
        # dp[i][j] 表示下标i到下标j的切片是否在字典中
        for i in range(n):
            for j in range(i, n):
                if s[i:j+1] in wordDict:
                    dp[i][j] = True
        ret = []
        ans = []
        def dfs(i: int):
            if i == n:
                temp = " ".join(ans)
                ret.append(temp)
                return 
            for j in range(i, n):
                if dp[i][j]:
                    ans.append(s[i:j+1])
                    dfs(j+1)
                    ans.pop()
        dfs(0)
        return ret
```

### 152、乘积最大子数组

>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。
>
>```
>示例:
>
>输入: [2,3,-2,4]
>输出: 6
>解释: 子数组 [2,3] 有最大乘积 6。
>
>输入: [-2,0,-1]
>输出: 0
>解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
>```

下面这种方法的时间复杂度是 `O(n^2)`，会超时。

```python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        n = len(nums)
        ans = -10e9
        dp = [[0] * n for _ in range(n)]
        for i in range(n):
            dp[i][i] = nums[i]
            ans = max(ans, dp[i][i])
            if i < n - 1:
                dp[i][i+1] = nums[i] * nums[i+1]
                ans = max(ans, dp[i][i+1])
        # L表示切片的长度
        for L in range(3, n + 1):
            for i in range(n):
                j = i + L - 1
                if j >= n:
                    continue
                dp[i][j] = dp[i+1][j-1] * nums[i] * nums[j]
                ans = max(ans, dp[i][j])
        return ans
```

可是，时间复杂度为 `O(n)` 的又不行。
![image-20211130154807367](https://gitee.com/ceyewan/pic/raw/master/images/image-20211130154807367.png)

回忆一下接雨水的那道题，一个一维 `dp` 数组解决不了怎么办？一个解决不了就用两个。我们可以用一个数组记录下最负可以是多少，然后记录下最正可以是多少。

```python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        n = len(nums)
        pos_dp = [0] * n
        neg_dp = [0] * n
        pos_dp[0] = nums[0]
        neg_dp[0] = nums[0]
        ans = pos_dp[0]
        for i in range(1, n):
            if nums[i-1] == 0 or nums[i] == 0:
                pos_dp[i] = nums[i]
                neg_dp[i] = nums[i]
                ans = max(ans, pos_dp[i])
            elif nums[i] > 0:
                pos_dp[i] = max(pos_dp[i-1] * nums[i], nums[i])
                neg_dp[i] = min(neg_dp[i-1] * nums[i], nums[i])
                ans = max(ans, pos_dp[i])
            else:
                pos_dp[i] = max(neg_dp[i-1] * nums[i], nums[i])
                neg_dp[i] = min(pos_dp[i-1] * nums[i], nums[i])
                ans = max(ans, pos_dp[i])
        return ans
```

### 174、地下城游戏To Do

>一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。
>
>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。
>
>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。
>
>为了尽快到达公主，骑士决定每次只***向右或向下***移动一步。
>
>编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。
>
>例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -> 右 -> 下 -> 下，则骑士的初始健康点数至少为 7。
>
>| -2 (K) | -3   | 3      |
>| ------ | ---- | ------ |
>| -5     | -10  | 1      |
>| 10     | 30   | -5 (P) |
>
>**说明:**
>
>- 骑士的健康点数没有上限。
>- 任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。

```
我有女朋友了，公主我不救了。
```

### 198、打家劫舍

>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
>
>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
>
>```
>示例：
>
>输入：[1,2,3,1]
>输出：4
>解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
>     偷窃到的最高金额 = 1 + 3 = 4 。
>
>输入：[2,7,9,3,1]
>输出：12
>解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
>     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
>```
>
>
>提示：
>
>- 1 <= nums.length <= 100
>- 0 <= nums[i] <= 400

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 1:
            return nums[0]
        dp = [0] * n
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])
        for i in range(2, n):
            dp[i] = max(dp[i-1], dp[i-2] + nums[i])
        return dp[n-1]
```

### 213、打家劫舍Ⅱ

>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。
>
>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。
>
>```
>示例：
>
>输入：nums = [2,3,2]
>输出：3
>解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
>
>输入：nums = [1,2,3,1]
>输出：4
>解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
>     偷窃到的最高金额 = 1 + 3 = 4 。
>
>输入：nums = [0]
>输出：0
>```
>
>
>提示：
>
>- 1 <= nums.length <= 100
>- 0 <= nums[i] <= 1000

意味着偷第一个房间，就得在倒数第二个房间结束；偷第二个房间，就能在倒数第一个房间结束。

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 1:
            return nums[0]
        dp = [0] * n
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])
        for i in range(2, n-1):
            dp[i] = max(dp[i-1], dp[i-2] + nums[i])
        ans1 = dp[n-2]
        dp[0] = 0
        dp[1] = nums[1]
        for i in range(2, n):
            dp[i] = max(dp[i-1], dp[i-2] + nums[i])
        ans2 = dp[n-1]
        return max(ans1, ans2)
```

### 337、打家劫舍Ⅲ

>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。
>
>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。
>
>```
>示例:
>
>输入: [3,2,3,null,3,null,1]
>      3
>     / \
>    2   3
>    \    \ 
>     3    1
>输出: 7 
>解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.
>
>输入: [3,4,5,1,3,null,1]
>     3
>    / \
>   4   5
>  / \   \ 
> 1   3   1
>输出: 9
>解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.
>```

这里到了树形 `dp` 领域了，为了方便理解，我们从最简单的方法开始写起，慢慢得到动态规划做法。

最简单的做法，递归。假如偷头节点，就不能偷它的两个子节点，假如不偷头节点，就可以偷它的两个子节点。

```python
class Solution:
    def rob(self, root: TreeNode) -> int:
        if root == None:
            return 0
        if root.right == None and root.left == None:
            return root.val
        ans1 = root.val
        if root.left:
            ans1 += self.rob(root.left.left)
            ans1 += self.rob(root.left.right)
        if root.right:
            ans1 += self.rob(root.right.left)
            ans1 += self.rob(root.right.right)
        ans2 = 0
        ans2 += self.rob(root.left)
        ans2 += self.rob(root.right)
        return max(ans1, ans2)
```

递归我们知道的，会有很多的重复计算。所以，如何优化呢？记忆化搜索，我们把求过的存起来，求过的就不求了，不就 ok 了？

```python
class Solution:
    memory = {}
    def rob(self, root: TreeNode) -> int:
        if root is None:
            return 0
        if root.left is None and root.right  is None:
            return root.val
        if self.memory.get(root) is not None:
            return self.memory[root]
        # 偷父节点
        ans1 = root.val
        if root.left:
            ans1 += self.rob(root.left.left) + self.rob(root.left.right)
        if root.right:
            ans1 += self.rob(root.right.left) + self.rob(root.right.right)
        # 不偷父节点
        ans2 = self.rob(root.left) + self.rob(root.right)
        # 字典存储
        self.memory[root] = max(val1, val2)
        return max(val1, val2)
```

我们递归为什么会很多重复呢？因为在算父节点的时候把孙节点算了，却没存下来，递归到子节点又得算一次孙节点。现在呢？我们在递归的时候，算出孙节点，返回给子节点，子节点收到这个返回了就不需要再次调用孙节点了。**在递归的过程中，系统栈会保存每一层递归的参数**。是我愚钝，说不清楚。好好悟一下，很妙。

递归下去，返回两个值：偷当前节点金额，不偷当前节点金额

```python
class Solution:
    def rob(self, root: TreeNode) -> int:
        result = self.rob_tree(root)
        return max(result[0], result[1])
    
    def rob_tree(self, node):
        if node is None:
            return (0, 0) # (偷当前节点金额，不偷当前节点金额)
        left = self.rob_tree(node.left)
        right = self.rob_tree(node.right)
        val1 = node.val + left[1] + right[1] # 偷当前节点，left[1]表示不偷左节点
        val2 = max(left[0], left[1]) + max(right[0], right[1]) 
        # 不偷当前节点，可偷可不偷子节点
        return (val1, val2)
```
以下为树形 DP 的一些题目：
 ```
 124. 二叉树中的最大路径和
 125. 二叉树的直径
 126. 二叉树最长连续序列
 127. 二叉树中最长的连续序列
 128. 最长同值路径
 129. 二叉树中的最长交错路径
 130. 具有所有最深节点的最小子树
 ```

### 221、最大正方形

>在一个由 '0' 和 '1' 组成的二维矩阵内，找到只包含 '1' 的最大正方形，并返回其面积。
>
> ![img](https://gitee.com/ceyewan/pic/raw/master/images/max1grid.jpg)
>
>```
>示例：
>
>输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
>输出：4
>```
>
>提示：
>
>- m == matrix.length
>- n == matrix[i].length
>- 1 <= m, n <= 300
>- `matrix[i][j]` 为 '0' 或 '1'

小改一下最大矩阵就好了。宽和高一定要相等，取最小值。

```python
class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        if len(matrix) == 0:
            return 0
        m, n = len(matrix), len(matrix[0])
        # 求出dp数组
        dp = [[0] * n for i in range(m)]
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == "1":
                    if j == 0:
                        dp[i][j] = 1
                    else:
                        dp[i][j] = dp[i][j - 1] + 1
        # length 表示矩形的宽，area表示最大面积
        length, area = 0, 0
        for i in range(m):
            for j in range(n):
                # 以坐标(i, j)为右下角的矩形
                if matrix[i][j] == "1":
                    # 高为1的时候（宽也是1）
                    length = dp[i][j]
                    area = max(area, 1)
                    # 往上探索高度，然后改变宽，求面积
                    for k in range(i - 1, -1, -1):
                        if matrix[k][j] == "0":
                            break
                        else:
                            length = min(length, dp[k][j])
                            # 宽和高一定要相等，取较小的那个
                            temp = min(length, i - k + 1)
                            area = max(area, temp * temp)
        return area
```

`dp[i][j]` 表示右下角为 `(i, j)` 的正方形的最大边长，依赖于左边、上面和左上的边长。如此的话，我们是不是可以应用于最大矩形那道题呢？似乎不太行。正方形维持一个边长就维持了一个面积，但是矩形维持着宽和高终究只是两条边，不知道面积内其他点的情况。

```python
class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        if len(matrix) == 0:
            return 0
        m, n = len(matrix), len(matrix[0])
        dp = [[0] * n for i in range(m)]
        area = 0
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == "1":
                    if i == 0 or j == 0:
                        dp[i][j] = 1
                        area = max(area, 1)
                    else:
                        dp[i][j] = min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]) + 1
                        area = max(area, dp[i][j] * dp[i][j])
        return area                    
```

###    233、数字1的个数

>给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。
>
>```
>示例：
>
>输入：n = 13
>输出：6
>
>输入：n = 0
>输出：0
>```
>
>
>提示：
>
>0 <= n <= 10^9

观察数据范围，这 tm 是个硬茬。

超时方法走一手先。此时 `dp` 必须要退化成一个数，不然占用空间太多。

```python
class Solution:
    def countDigitOne(self, n: int) -> int:
        dp = 0
        for i in range(1, n + 1):
            s = str(i)
            count = 0
            for j in range(len(s)):
                if s[j] == "1":
                    count += 1
            dp += count
        return dp
```

下面的解法很烂。我的想法是这样的。比如说考虑数 `581621` 吧。我们看 `100000` 以内（不包括本身）出现了多少个 `1` 呢？答案是 `dp[5]` 。`100000` 到 `200000` 呢？最前面的 `1` 出现了 `10^5` 个，后面 `5` 位出现了 `dp[5]` 次。以此类推，得到 `500000` 以内包括 `5 * dp[5] + 10^5` 个 `1` 。

然后我们考虑第一位确定是 `5` ，第二位为 0 时，后面出现了 `dp[4]` 个 `1` ；第二位为 `1` 时，后面出现了 `dp[4]` 个 `1` ；第二位为 `2` 时，后面出现了 `dp[4]` 个 `1` ……，还得考虑第二位的 `1` 出现了 `10^4` 个。

我们看 `581` 的 `1` 出现了多少次呢？ `10^3` 个？并不是，因为后面并没有把所有的三位数确定完。出现了 `622` 次（后面从 `000` 到 `621`）。

以此类推。

```python
class Solution:
    def countDigitOne(self, n: int) -> int:
        # dp[i]表示所有i位数中1的个数
        dp = [0] * 11
        dp[0] = 0
        dp[1] = 1
        for i in range(2, 11):
            dp[i] = dp[i - 1] * 10 + 10 ** (i - 1)
        s = str(n)
        weishu = len(s)
        count = 0
        for i in range(weishu):
            if int(s[i]) > 1:
                count += int(s[i]) * dp[weishu - i - 1] + 10 ** (weishu - i - 1)
            # i < weishu - 1 是为了防止切片越界
            elif int(s[i]) == 1 and i < weishu - 1:
                count += dp[weishu - i - 1] + int(s[i + 1:]) + 1
            elif int(s[i]) == 1 and i == weishu - 1:
                count += dp[weishu - i - 1] + 1
        return count
```

官方题解，考虑  `581621` 。百位上 `1` 出现多少次呢？百位以上可以从 `000` 到 `581` ，百位以下可以从 `00` 到 `99`，那么百位的 `1` 出现了 `582 * 100` 次。

千位上 `1` 出现了多少次呢？`59 * 1000` ？不是的。出现了 `58 * 1000 + 622` 次。前面取 `00` 到 `58` 的时候，后面就可以随意选择。前面取 `59` 后面只能取到 `621` 。

然后再考虑好边界就好了。

```python
class Solution:
    def countDigitOne(self, n: int) -> int:
        s = str(n)
        length = len(s)
        # 边界加0方便考虑，切片不会越界
        s = "0" + s + "0"
        count = 0
        for i in range(1, length + 1):
            if int(s[i]) > 1:
                count += (int(s[:i]) + 1) * 10 ** (length - i)
            elif int(s[i]) == 1:
                count += int(s[:i]) * 10 ** (length - i)
                count += (int(s[i + 1:]) // 10 + 1)
            elif int(s[i]) == 0:
                count += int(s[:i]) * 10 ** (length - i)
        return count                 
```

### 241、为运算表达式设计优先级

>给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。
>
>```
>示例:
>
>输入: "2-1-1"
>输出: [0, 2]
>解释: 
>((2-1)-1) = 0 
>(2-(1-1)) = 2
>
>输入: "2*3-4*5"
>输出: [-34, -14, -10, -10, 10]
>解释: 
>(2*(3-(4*5))) = -34 
>((2*3)-(4*5)) = -14 
>((2*(3-4))*5) = -10 
>(2*((3-4)*5)) = -10 
>(((2*3)-4)*5) = 10
>```

我们先把这个表达式拆开，因为数字长度不定，所以采用滑动窗口的方法。得到一个列表。

我们可以发现，列表的偶数个都是数字，奇数个都是运算符。

创建二维列表，列表的元素同样也是一个列表。`dp[i][j]` 表示列表的第 `i` 个元素到第 `j` 个元素可能结果的和。很容易知道，`i` 和 `j` 一定都是偶数。

要求 `dp[i][j]`我们可以从 `k` 处切开 `(i <= k < j)` ，`k` 也必须是偶数。`dp[i][k]` 和 `dp[k + 2][j]` 的可行结果组合到一起，就是 `dp[i][j]` 所有的可行结果。

```python
class Solution:
    def diffWaysToCompute(self, expression: str) -> List[int]:
        list = []
        left, right = 0, 0
        while right < len(expression):
            while right < len(expression) - 1 and expression[right + 1] != "+" and expression[right + 1] != "-" and expression[right + 1] != "*":
                right += 1
            temp = expression[left:right+1]
            list.append(int(temp))
            if right < len(expression) - 1:
                list.append(expression[right + 1])
            left = right + 2
            right = left
        m = len(list)
        dp = [[[] for i in range(m)] for i in range(m)]
        for i in range(0, m, 2):
            dp[i][i].append(list[i])
            if i + 2 < m:
                if list[i + 1] == "+":
                    dp[i][i + 2].append(list[i] + list[i + 2])
                if list[i + 1] == "-":
                    dp[i][i + 2].append(list[i] - list[i + 2])
                if list[i + 1] == "*":
                    dp[i][i + 2].append(list[i] * list[i + 2])
        # L 表示长度
        for L in range(5, m + 1, 2):
            # i 表示起始位置
            for i in range(0, m, 2):
                # j 表示终止位置
                j = L + i - 1
                if j >= m:
                    break
                for k in range(i, j, 2):
                    if list[k + 1] == "*":
                        temp = [p * q for p in dp[i][k] for q in dp[k + 2][j]]
                        dp[i][j] += temp # 注意这里是 +=，每一个 k
                    if list[k + 1] == "+":
                        temp = [p + q for p in dp[i][k] for q in dp[k + 2][j]]
                        dp[i][j] += temp
                    if list[k + 1] == "-":
                        temp = [p - q for p in dp[i][k] for q in dp[k + 2][j]]
                        dp[i][j] += temp
        return dp[0][m - 1]                  
```

### 264、丑数Ⅱ

>给你一个整数 n ，请你找出并返回第 n 个 丑数 。
>
>丑数 就是只包含质因数 2、3 和/或 5 的正整数。
>
>```
>示例：
>
>输入：n = 10
>输出：12
>解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。
>
>输入：n = 1
>输出：1
>解释：1 通常被视为丑数。
>```
>
>
>提示：
>
>- 1 <= n <= 1690

我们知道后面的丑数都是前面的丑数 `* 2`  /  `* 3`  /  `*5` 得到的。比如说 `1 2 3 4 5 6 8 10`，`2` 是 `1 * 2`， `3` 是 `1 * 3`， `5` 是 `1 * 5`， `4` 是 `2 * 2`， `6` 是 `2 * 3`， `10` 是 `2 * 5` 。每一个数都可以生成三个丑数。但是，顺序我们是不知道的。所以用三个指针来表示。每个数字在三个指针的作用下，生成三个数。

其实就是我们可以每个数都乘以 `2`，`3`，`5` 然后加到列表中，但是就会用重复的，而且还需要排序。

```python
class Solution:
    def nthUglyNumber(self, n: int) -> int:
        dp = [0] * (n + 1)
        dp[1] = 1
        p2 = p3 = p5 = 1
        for i in range(2, n + 1):
            # 乘 2 的指针，乘 3 的指针，乘 5 的指针
            num2, num3, num5 = dp[p2] * 2, dp[p3] * 3, dp[p5] * 5
            # 因为要排序，所以只选择最小的
            dp[i] = min(num2, num3, num5)
            # 得到最下的那个指针就可以后移一个了
            if num2 == dp[i]:
                p2 += 1
            # 不用 elif 是因为可能两个或者三个都相等，为了去重
            if num3 == dp[i]:
                p3 += 1
            if num5 == dp[i]:
                p5 += 1
        return dp[n]
```

### 279、完全平方数

>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。
>
>给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。
>
>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。
>
>```
>示例：
>
>输入：n = 12
>输出：3 
>解释：12 = 4 + 4 + 4
>
>输入：n = 13
>输出：2
>解释：13 = 4 + 9
>```
>
>提示：
>
>- 1 <= n <= 10^4

```python
class Solution:
    def numSquares(self, n: int) -> int:
        dp = [10e9] * (n + 1)
        dp[0] = 0
        for i in range(1, n + 1):
            for j in range(1, int(sqrt(i)) + 1):
                dp[i] = min(dp[i], dp[i - j * j] + 1)
        return dp[n]
```

### 300、最长递增子序列

>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
>
>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。
>
>```
>示例：
>
>输入：nums = [10,9,2,5,3,7,101,18]
>输出：4
>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
>
>输入：nums = [0,1,0,3,2,3]
>输出：4
>
>输入：nums = [7,7,7,7,7,7,7]
>输出：1
>```
>
>提示：
>
>- 1 <= `nums.length` <= 2500
>- -10^4 <= `nums[i]` <= 10^4
>
>**进阶：**
>
>- 你可以设计时间复杂度为 `O(n2)` 的解决方案吗？
>- 你能将算法的时间复杂度降低到 `O(n log(n))` 吗?

`dp[i]` 表示下标 `i` 结尾的最长递增子序列的长度。

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [1] * n
        ans = 1
        for i in range(1, n):
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j] + 1)
                    ans = max(ans, dp[i])
        return ans
```

优化：

我们用 `tails[i]` 代表长度为 `i+1` 的子序列尾部元素的最小值。于是，我们知道，这一定是一个递增的数列。为什么呢？长度为 4 的递增子序列的最后一个元素会比长度为 3 的递增子序列的最后一个元素小吗？开玩笑吧。然后我们考虑一个数，如果它没有最后一个数大，那么结果是不会变的。但是，可以更新一个 `tails` 的值。

举个例子吧。`nums = [0,1,0,3,2,3]`，假设前 4 个数已经考虑好了，那么 `tails` 为 `[0, 1, 3]`，我们考虑第四个数：2 。二分查找，我们发现 2 小于 3，那么 2 就可以代替 3 的位置。即 `tails` 为 `[0, 1, 2]` 。我们再考虑 3，全都比 3 小，那么 `tails` 就可以增加一个了，即 `tails = [0, 1, 2, 3]` 。

`tails` 的长度就是答案。

```python
class Solution:
    def lengthOfLIS(self, nums: [int]) -> int:
        # tails[i] 代表长度为 i+1 的子序列尾部元素的最小值。
        # res 代表 tails 的长度
        tails, res = [0] * len(nums), 0
        for num in nums:
            left, right = 0, res
            while left < right:
                mid = (left + right) // 2
                if tails[mid] < num: 
                    left = mid + 1 # 如果要求非严格递增，将此行 '<' 改为 '<=' 即可。
                else: 
                    right = mid
            tails[left] = num
            if right == res: res += 1
        return res
```

### 312、戳气球

>有 n 个气球，编号为0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。
>
>现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。
>
>求所能获得硬币的最大数量。
>
>```
>示例：
>输入：nums = [3,1,5,8]
>输出：167
>解释：
>nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []
>coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167
>
>输入：nums = [1,5]
>输出：10
>```

逆向思维。戳气球会导致两个气球从不相邻变成相邻，使得后续操作难以处理。于是我们倒过来看这些操作，将全过程看作是每次添加一个气球。

记忆化搜索。首先我们的列表是这样的 [1,3,1,5,8,1]，没有加粗，表示还没有进入列表。然后我们选择 8 加入列表，也就是变成这样 [1,3,1,5,***8***,1] ，我们以 1 和 8 作为左边这一段的边界，从中间选择 3 加入列表。即   [1,***3***,1,5,***8***,1]  ，然后是 [1,***3***,1,***5***,***8***,1] ，最后是 [1,***3***,***1***,***5***,***8***,1] 。戳气球的过程反过来就行了。

```python
class Solution:
    def maxCoins(self, nums: List[int]) -> int:
        n = len(nums)
        # 两边加上1方便考虑
        val = [1] + nums + [1]
        @lru_cache(None) # 记忆化
        def solve(left: int, right: int) -> int:
            if left >= right - 1:
                return 0
            best = 0
            # 遍历每一个可以添加的值
            for i in range(left + 1, right):
                # 添加 i ，这个时候其实数组里面是没有元素的（其他的还没添加）
                total = val[left] * val[i] * val[right]
                total += solve(left, i) + solve(i, right)
                best = max(best, total)
            return best
        return solve(0, n + 1)
```

动态规划，都有了上面那个了，动态规划还不好写吗？记忆化换成 `dp` 数组。

```python
class Solution:
    def maxCoins(self, nums: List[int]) -> int:
        n = len(nums)
        val = [1] + nums + [1]
        dp = [[-1] * (n + 2) for i in range(n + 2)]
        def solve(left: int, right: int) -> int:
            if dp[left][right] != -1:
                return dp[left][right]
            if left >= right - 1:
                dp[left][right] = 0
                return 0
            best = 0
            for i in range(left + 1, right):
                total = val[left] * val[i] * val[right]
                total += solve(left, i) + solve(i, right)
                best = max(best, total)
            dp[left][right] = best
            return best
        return solve(0, n + 1)
```

其实这个自底向上写也挺简单的。主要还是这个逆向思维。`dp[i][j]` 表示填满***开***区间 `(i,j)` 能得到的最多硬币数。

```python
class Solution:
    def maxCoins(self, nums: List[int]) -> int:
        n = len(nums)
        val = [1] + nums + [1]
        dp = [[0] * (n + 2) for i in range(n + 2)]
        for i in range(n - 1, -1, -1):
            for j in range(i + 2, n + 2):
                for k in range(i + 1, j):
                    total = val[i] * val[k] * val[j]
                    total += dp[i][k] + dp[k][j]
                    dp[i][j] = max(dp[i][j], total)
        return dp[0][n + 1]
#dp版本代码，最外层的循环，i为什么是n-1 -> 0，而不能反过来？
#(i,j) 0 1  2   3   4   ...   n-2   n-1   n   n+1
#0     0 1  2   3   4   ...                   n+1
#1       1  2   3   4   ...                   n+1
#2          2   3   4   ...                   n+1
#3              3   4   ...                   n+1
#4                  4                         n+1
#.                      .                     .
# .                         .                  .
#n-2                          n-2   n-1   n   n+1
#n-1                                n-1   n   n+1
#n+1
# 须从下往上算，即先算dp[n-1][n+1]：
# 根据递推关系，算dp[i][j]时依赖的dp[i][k]和dp[k][j]，其中i<k<j。
# 1、如果从上往下计算，依赖的dp[k][j]根本就还未算出（k比i大），
#    比如算dp[0][3]时，依赖的dp[1][3]还是个未知数。
# 2、从下往上就不一样，算dp[i][j]时，依赖的dp[i][k]，位于同一行左侧，已计算过；
#    依赖的dp[k][j]，因为k>i，位于更下面的行，也已计算过。
```

说实话，记忆化搜索好的多，就是递归栈复杂一点，但是顶不住它好想啊。

### 313、超级丑数

>超级丑数 是一个正整数，并满足其所有质因数都出现在质数数组 primes 中。
>
>给你一个整数 n 和一个整数数组 primes ，返回第 n 个 超级丑数 。
>
>题目数据保证第 n 个 超级丑数 在 32-bit 带符号整数范围内。
>
>```
>示例：
>
>输入：n = 12, primes = [2,7,13,19]
>输出：32 
>解释：给定长度为 4 的质数数组 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。
>
>输入：n = 1, primes = [2,3,5]
>输出：1
>解释：1 不含质因数，因此它的所有质因数都在质数数组 primes = [2,3,5] 中。
>```
>
>提示：
>
>- 1 <= n <= 10^6
>- 1 <= primes.length <= 100
>- 2 <= primes[i] <= 1000
>- 题目数据 保证 primes[i] 是一个质数
>- primes 中的所有值都 互不相同 ，且按 递增顺序 排列

这里和上面本质上是一样的，上面有 `3` 个数，就搞了 `3` 个指针，这里有 `n` 个数，我们就搞 `n` 个指针。然后得到的数呢，我们就全部放在一个列表里面，每次拿出最小的那个给 `dp` 。然后我们拿出来的是第 `j` 个，说明第 `j` 个指针需要往后移动一个，第 `j` 个数据也可以更新了。

```python
class Solution:
    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:
        dp = [0] * (n + 1)
        m = len(primes)
        pointers = [0] * m
        nums = [1] * m
        for i in range(1, n + 1):
            min_num = min(nums)
            dp[i] = min_num
            for j in range(m):
                if nums[j] == min_num:
                    pointers[j] += 1
                    nums[j] = dp[pointers[j]] * primes[j]
        return dp[n]
```



