### 灯泡开关

[灯泡开关](https://leetcode-cn.com/problems/bulb-switcher/)

>初始时有 n 个灯泡处于关闭状态。第一轮，你将会打开所有灯泡。接下来的第二轮，你将会每两个灯泡关闭一个。
>
>第三轮，你每三个灯泡就切换一个灯泡的开关（即，打开变关闭，关闭变打开）。第 i 轮，你每 i 个灯泡就切换一个灯泡的开关。直到第 n 轮，你只需要切换最后一个灯泡的开关。
>
>找出并返回 n 轮后有多少个亮着的灯泡。

**提示：**

- `0 <= n <= 10^9`

###  思路

模拟，超时。

```c
int bulbSwitch(int n){
    if (n <= 0)
        return 0;
    int count = 0;
    int sign[n];
    memset(sign, 0, sizeof(sign));
    for (int i = 1; i <= n; i++) {
        int j = -1;
        do {
            j += i;
            if (j < n)
                sign[j] ^= 1;
        }while (j < n);
    }
    for (int i = 0; i < n; i++) 
        if(sign[i])
            count++;
    return count;
}
```

属于是震惊两分钟了。首先我们看到 n 最大能够取到 10^9 ，那么像模拟这种时间复杂度超过 n 的几乎都过不了了。于是问题就只剩下了一组解：奇技淫巧。我们考虑一个数 k ，那么它会被改变几次呢？有几个因子就改变几次。比如 24 在 1、2、3、4、6、8、12、24的时候都会改变。而且我们看到都是配对的，1和24， 2和12……。也就是说改变偶数次，换句话说就是不改变。只有完全平方数是奇数个。也就是说我们考虑 n 以内有多少个完全平方数就好了，也就是 `(int)sqrt(n)`。

```c
int bulbSwitch(int n){
    return sqrt(n);
}
```

