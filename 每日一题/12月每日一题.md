### 1446、连续字符

>给你一个字符串 s ，字符串的「能量」定义为：只包含一种字符的最长非空子字符串的长度。
>
>请你返回字符串的能量。
>
>```
>示例：
>
>输入：s = "leetcode"
>输出：2
>解释：子字符串 "ee" 长度为 2 ，只包含字符 'e' 。
>
>输入：s = "abbcccddddeeeeedcba"
>输出：5
>解释：子字符串 "eeeee" 长度为 5 ，只包含字符 'e' 。
>```
>
>
>提示：
>
>1 <= s.length <= 500
>s 只包含小写英文字母。

#### 暴力法

双循环。只要数据允许，怎么简单怎么来。

```python
class Solution:
    def maxPower(self, s: str) -> int:
        m = len(s)
        ans = 0
        for i in range(m):
            count = 0
            for j in range(i, m):
                if s[j] == s[i]:
                    count += 1
                else:
                    break
            ans = max(ans, count)
        return ans
```

#### 滑动窗口

left 和 right 之间始终维持只包含一种字符。

```python
class Solution:
    def maxPower(self, s: str) -> int:
        m = len(s)
        ans = 0
        left = 0
        right = 0
        while right < m - 1 and s[right + 1] == s[left]:
            right += 1
        ans = max(ans, right - left + 1)
        while right < m - 1:
            left = right + 1
            right = left
            while right < m - 1 and s[right + 1] == s[left]:
                right += 1 
            ans = max(ans, right - left + 1)
        return ans
```

#### 动态规划

很显然，上面的滑动窗口已经是很好的解了，不过，既然最近在学动态规划，那就用动态规划写一下吧。

```python
class Solution:
    def maxPower(self, s: str) -> int:
        m = len(s)
        dp = [1] * m
        ans = 1
        for i in range(1, m):
            if s[i] == s[i - 1]:
                dp[i] = dp[i - 1] + 1
                ans = max(ans, dp[i])
            else:
                dp[i] = 1
        return ans
```

### 509、相对名次

>给你一个长度为 n 的整数数组 score ，其中 score[i] 是第 i 位运动员在比赛中的得分。所有得分都 互不相同 。
>
>运动员将根据得分 决定名次 ，其中名次第 1 的运动员得分最高，名次第 2 的运动员得分第 2 高，依此类推。运动员的名次决定了他们的获奖情况：
>
>1. 名次第 1 的运动员获金牌 "Gold Medal" 。
>2. 名次第 2 的运动员获银牌 "Silver Medal" 。
>3. 名次第 3 的运动员获铜牌 "Bronze Medal" 。
>4. 从名次第 4 到第 n 的运动员，只能获得他们的名次编号（即，名次第 x 的运动员获得编号 "x"）。
>     使用长度为 n 的数组 answer 返回获奖，其中 answer[i] 是第 i 位运动员的获奖情况。
>
>```
>示例：
>
>输入：score = [5,4,3,2,1]
>输出：["Gold Medal","Silver Medal","Bronze Medal","4","5"]
>解释：名次为 [1st, 2nd, 3rd, 4th, 5th] 。
>
>输入：score = [10,3,8,9,4]
>输出：["Gold Medal","5","Bronze Medal","Silver Medal","4"]
>解释：名次为 [1st, 5th, 3rd, 2nd, 4th] 。
>```
>
>
>提示：
>
>- n == score.length
>- 1 <= n <= 10^4
>- 0 <= score[i] <= 10^6
>- score 中的所有值 互不相同

#### 结构体数组

用一个结构体数组保存下标和得分，然后对结构体数组按照得分从高到低排序。

```c
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
typedef struct {
    int index;
    int score;
}Score;
int comp(void const *a, void const *b)
{
    return ((Score *)a)->score < ((Score *)b)->score;
}
char ** findRelativeRanks(int* score, int scoreSize, int* returnSize){
    char **ans = (char **)malloc(sizeof(char *) * scoreSize);
    *returnSize = scoreSize;
    Score s[scoreSize];
    for (int i = 0; i < scoreSize; i++) {
        s[i].index = i;
        s[i].score = score[i];
    }
    qsort(s, scoreSize, sizeof(Score), comp);
    for (int i = 0; i < scoreSize; i++) {
        if (i == 0)
            ans[s[0].index] = "Gold Medal";
        else if (i == 1)
            ans[s[1].index] = "Silver Medal";
        else if (i == 2)
            ans[s[2].index] = "Bronze Medal";
        else {
            char *temp = (char *)malloc(sizeof(char) * 5);
            sprintf(temp, "%d", i + 1);
            ans[s[i].index] = temp;
        }
    }
    return ans;
}
```

#### python解法

```python
class Solution:
    desc = ("Gold Medal", "Silver Medal", "Bronze Medal")
    def findRelativeRanks(self, score: List[int]) -> List[str]:
        # 字符串列表
        ans = [""] * len(score)
        # enumerate（）函数接受一个集合（例如元组），并将其作为枚举对象返回。
        # sorted() 函数对所有可迭代的对象进行排序操作。
        # lambda,匿名函数，接受参数x，返回-x[1]
        # 表示按照第二个元素降序排序，arr是一个列表，里面的元素都形如（1，5）
        arr = sorted(enumerate(score), key=lambda x: -x[1])
        for i, (idx, _) in enumerate(arr):
       	# i是arr的下标，idx是在score里的下标，_是得分
            ans[idx] = self.desc[i] if i < 3 else str(i + 1)
        return ans
```

### 1005、k次取反后最大化的数组和

>给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：
>
>- 选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。
>
>重复这个过程恰好 k 次。可以多次选择同一个下标 i 。
>
>以这种方式修改数组后，返回数组 可能的最大和 。
>
>```
>示例：
>
>输入：nums = [4,2,3], k = 1
>输出：5
>解释：选择下标 1 ，nums 变为 [4,-2,3] 。
>
>输入：nums = [3,-1,0,2], k = 3
>输出：6
>解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。
>
>输入：nums = [2,-3,-1,5,-4], k = 2
>输出：13
>解释：选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] 。
>```
>
>
>提示：
>
>- 1 <= nums.length <= 10^4
>- -100 <= nums[i] <= 100
>- 1 <= k <= 10^4

#### 贪心

有负的，我们肯定是优先把最负的修改正的。然后剩下的修改次数如果是偶数，就可以认为是不修改。如果是奇数，就可以认为只修改一次。同样贪心的选择最小的修改成负的。

```c
int comp(void const *a, void const *b)
{
    return *(int *)a > *(int *)b;
}
int largestSumAfterKNegations(int* nums, int numsSize, int k){
    qsort(nums, numsSize, sizeof(int), comp);
    int i = 0;
    while (i < numsSize && nums[i] < 0 && k > 0) {
        nums[i] = -nums[i];
        i++;
        k--;
    }
    if (k % 2 == 1) {
        if (i != numsSize && (i == 0 || nums[i] < nums[i - 1]))
            nums[i] = -nums[i];
        else
            nums[i - 1] = -nums[i - 1];
    }
    int sum = 0;
    for (int i = 0; i < numsSize; i++)
        sum += nums[i];
    return sum;
}
```

然而注意到本题中数组元素的范围为 [-100, 100][−100,100]，因此我们可以使用计数数组（桶）或者哈希表，直接统计每个元素出现的次数，再升序遍历元素的范围，这样就省去了排序需要的时间。

```python
class Solution:
    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:
        freq = Counter(nums)
        ans = sum(nums)
        for i in range(-100, 0):
            # i出现过
            if freq[i] > 0:
                # x
                ops = min(k, freq[i])
                ans += -i * ops * 2
                freq[i] -= ops
                freq[-i] += ops
                k -= ops
                if k == 0:
                    break
        
        if k > 0 and k % 2 == 1 and not freq[0]:
            for i in range(1, 101):
                if freq[i]:
                    ans -= i * 2
                    break        
        return ans
```

### 383、赎金信

>为了不在赎金信中暴露字迹，从杂志上搜索各个需要的字母，组成单词来表达意思。
>
>给你一个赎金信 (ransomNote) 字符串和一个杂志(magazine)字符串，判断 ransomNote 能不能由 magazines 里面的字符构成。
>
>如果可以构成，返回 true ；否则返回 false 。
>
>magazine 中的每个字符只能在 ransomNote 中***使用一次***。
>
>```
>示例：
>
>输入：ransomNote = "a", magazine = "b"
>输出：false
>
>输入：ransomNote = "aa", magazine = "ab"
>输出：false
>
>输入：ransomNote = "aa", magazine = "aab"
>输出：true
>```
>
>
>提示：
>
>- 1 <= ransomNote.length, magazine.length <= 105
>
>- ransomNote 和 magazine 由小写英文字母组成

#### 哈希表

简单题我重拳出击。

因为只有 26 个字母，所以用个数组即可。

```c
int sign[26];
bool canConstruct(char * ransomNote, char * magazine){
    memset(sign, 0, sizeof(int) * 26);
    for (int i = 0; magazine[i] != '\0'; i++) {
        sign[magazine[i] - 'a']++;
    }
    for (int i = 0; ransomNote[i] != '\0'; i++) {
        sign[ransomNote[i] - 'a']--;
        if (sign[ransomNote[i] - 'a'] < 0)
            return false;
    }
    return true;
}
```

python 是真短啊。

```python
class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -> bool:
        if len(ransomNote) > len(magazine):
            return False
        return not collections.Counter(ransomNote) - collections.Counter(magazine)
```

### 372、超级次方

>你的任务是计算 `ab` 对 `1337` 取模，`a` 是一个正整数，`b` 是一个非常大的正整数且会以数组形式给出。
>
>```
>示例 2：
>输入：a = 2, b = [1,0]
>输出：1024
>```
>
>**提示：**
>
>- `1 <= a <= 2^31 - 1`
>- `1 <= b.length <= 2000`
>- `0 <= b[i] <= 9`
>- `b` 不含前导 0

秦九韶算法。比如我们看 2^4321，其实是求 `2^1 * (2^432)^10`，里面是不是又可以递归下去。外面就是两个 pow 相乘。

取模的操作满足分配率，我们看：![image-20211205154154304](https://gitee.com/ceyewan/pic/raw/master/images/image-20211205154154304.png)

```c
int mod = 1337;
// 函数里面取模过了
int my_pow(int a, int b)
{
    int ans = 1;
    a %= mod;
    while (b-- > 0) ans = ans * a % mod;
    return ans;
}
int dfs(int a, int *b, int len)
{
    if (len == -1)  return 1;
    // 这里还得取个模
    return my_pow(dfs(a, b, len - 1), 10) * my_pow(a, b[len]) % mod;
}
int superPow(int a, int* b, int bSize){
    return dfs(a, b, bSize - 1);
}
```

求 pow 还有一种快速幂方法，我们看 求 2^108 次方，真的需要把 2 自乘 108 次吗？不用的。可以求 (2^54)^2 ，依此类推。

### 1816、截断句子

>句子 是一个单词列表，列表中的单词之间用单个空格隔开，且不存在前导或尾随空格。每个单词仅由大小写英文字母组成（不含标点符号）。
>
>例如，"Hello World"、"HELLO" 和 "hello world hello world" 都是句子。
>给你一个句子 s 和一个整数 k ，请你将 s 截断 ，使截断后的句子仅含 前 k 个单词。返回 截断 s 后得到的句子。
>
>```
>示例：
>
>输入：s = "Hello how are you Contestant", k = 4
>输出："Hello how are you"
>解释：
>s 中的单词为 ["Hello", "how" "are", "you", "Contestant"]
>前 4 个单词为 ["Hello", "how", "are", "you"]
>因此，应当返回 "Hello how are you"
>```
>
>提示：
>
>- 1 <= s.length <= 500
>- k 的取值范围是 [1,  s 中单词的数目]
>- s 仅由大小写英文字母和空格组成
>- s 中的单词之间由单个空格隔开
>- 不存在前导或尾随空格

```c++
class Solution {
public:
    string truncateSentence(string s, int k) {
        int n = s.size();
        for (int i = 0; i < n; i++) {
            if (s.at(i) == ' ') {
                k--;
                if (k == 0) {
                    return s.substr(0, i);
                }
            }
        }
        return s;
    }
};
```

### 1034、边界着色

>给你一个大小为 m x n 的整数矩阵 grid ，表示一个网格。另给你三个整数 row、col 和 color 。网格中的每个值表示该位置处的网格块的颜色。
>
>两个网格块属于同一 连通分量 需满足下述全部条件：
>
>- 两个网格块颜色相同
>
>- 在上、下、左、右任意一个方向上相邻
>
>连通分量的边界 是指连通分量中满足下述条件之一的所有网格块：
>
>在上、下、左、右四个方向上与不属于同一连通分量的网格块相邻
>在网格的边界上（第一行/列或最后一行/列）
>请你使用指定颜色 color 为所有包含网格块`grid[row][col]`的连通分量的***边界***进行着色，并返回最终的网格 grid
>
>。
>
>```
>示例：
>
>输入：grid = [[1,1,1],[1,1,1],[1,1,1]], row = 1, col = 1, color = 2
>输出：[[2,2,2],[2,1,2],[2,2,2]]
>```
>
>提示：
>
>- m == grid.length
>- n == grid[i].length
>- 1 <= m, n <= 50
>- 1 <= `grid[i][j]`, color <= 1000
>- 0 <= row < m
>- 0 <= col < n

![img](https://gitee.com/ceyewan/pic/raw/master/images/4C214B25697EEA80792FE42E610D091A.jpg)

看懂题意，手撸C语言。

```c
#define MAX 2501
// 队列
typedef struct {
    int x;
    int y;
}qu;
qu queue[MAX];
// 方向
int dir[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
// 判断是否为边界
bool isboundary(int **grid, int x, int y, int m, int n)
{
    if (x == 0 || x == m - 1 || y == 0 || y == n - 1)
        return true;
    for (int i = 0; i < 4; i++) {
        int x1 = x + dir[i][0];
        int y1 = y + dir[i][1];
        if (grid[x1][y1] != grid[x][y])
            return true;
    }
    return false;
}
// 是否在 map 中
bool inmap(int x, int y, int m, int n)
{
    return 0 <= x && x < m && 0 <= y && y < n;
}
int** colorBorder(int** grid, int gridSize, int* gridColSize, int row, int col, int color, int* returnSize, int** returnColumnSizes){
    int m = gridSize, n = gridColSize[0];
    // 拷贝一份grid，确定好返回值
    int **ans = (int **)malloc(sizeof(int *) * m);
    for (int i = 0; i < m; i++) {
        int *temp = (int *)malloc(sizeof(int) * n);
        for (int j = 0; j < n; j++) {
            temp[j] = grid[i][j];
        }
        ans[i] = temp;
    }
    *returnSize = m;
    *returnColumnSizes = (int *)malloc(sizeof(int) * m);
    for (int i = 0; i < m; i++)
        (*returnColumnSizes)[i] = n;
    // 标记是否入队
    int sign[m][n];
    memset(sign, 0, sizeof(sign));
    // bfs
    int front = 0, rear = 0;
    queue[front].x = row;
    queue[front++].y = col;
    sign[row][col] = 1;
    while (rear < front) {
        int x = queue[rear].x;
        int y = queue[rear++].y;
        for (int k = 0; k < 4; k++) {
            int x1 = x + dir[k][0];
            int y1 = y + dir[k][1];
            if (inmap(x1, y1, m, n) && grid[x1][y1] == grid[row][col] && sign[x1][y1] == 0) {
                queue[front].x = x1;
                queue[front++].y = y1;
                sign[x1][y1] = 1;
            }
        }
    }
    // 队列中的元素且位于边界则需要着色
    for (int i = 0; i < front; i++) {
        int x = queue[i].x;
        int y = queue[i].y;
        if (isboundary(grid, x, y, m, n))
            ans[x][y] = color;
    }
    return ans;
}
```

`C++` + `dfs`

```c++
typedef pair<int, int> pii;
class Solution {
public:
    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {
        int m = grid.size(), n = grid[0].size();
        vector<vector<bool>> visited(m, vector<bool>(n, false));
        vector<pii> borders;
        int originalColor = grid[row][col];
        visited[row][col] = true;
        dfs(grid, row, col, visited, borders, originalColor);
        for (auto & [x, y] : borders) {
            grid[x][y] = color;
        }
        return grid;
    }
    void dfs(vector<vector<int>> &grid, int x, int y, vector<vector<bool>> &visited, vector<pii> &borders, int originalColor) {
        int m = grid.size(), n = grid[0].size();
        bool isBorder = false;
        int dir[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        for (int i = 0; i < 4; i++) {
            int nx = x + dir[i][0];
            int ny = y + dir[i][1];
            // 如果它四周的元素不在 map 里，或者不等于 originalColor ，那么它就是边界
            if (!(nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] == originalColor)) {
                isBorder = true;
            } else if (!visited[nx][ny]) {
                visited[nx][ny] = true;
                dfs(grid, nx, ny, visited, borders, originalColor);
            }
        }
        if (isBorder) {
            borders.emplace_back(x, y);
            // borders.push_back(pii(x, y));等价于这个
        }
    }
};
```

`C++` + `bfs`

```C++
typedef pair<int,int> pii;

class Solution {
public:
    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {
        int m = grid.size(), n = grid[0].size();
        vector<vector<bool>> visited(m, vector<bool>(n, false));
        vector<pii> borders;
        int originalColor = grid[row][col];
        int direc[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        queue<pii> q;
        q.emplace(row, col);
        visited[row][col] = true;
        while (!q.empty()) {
            pii & node = q.front();
            q.pop();
            int x = node.first, y = node.second;

            bool isBorder = false;
            for (int i = 0; i < 4; i++) {
                int nx = direc[i][0] + x, ny = direc[i][1] + y;
                if (!(nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] == originalColor)) {
                    isBorder = true;
                } else if (!visited[nx][ny]) {
                    visited[nx][ny] = true;
                    q.emplace(nx, ny);
                }         
            }
            if (isBorder) {
                borders.emplace_back(x, y);
            }
        }
        for (auto & [x, y] : borders) {
            grid[x][y] = color;
        }
        return grid;
    }
};
```

### 689、三个无重叠子数组的最大和

>给你一个整数数组 nums 和一个整数 k ，找出三个长度为 k 、互不重叠、且 3 * k 项的和最大的子数组，并返回这三个子数组。
>
>以下标的数组形式返回结果，数组中的每一项分别指示每个子数组的起始位置（下标从 0 开始）。如果有多个结果，返回字典序最小的一个。
>
>```
>示例：
>
>输入：nums = [1,2,1,2,6,7,5,1], k = 2
>输出：[0,3,5]
>解释：子数组 [1, 2], [2, 6], [7, 5] 对应的起始下标为 [0, 3, 5]。
>也可以取 [2, 1], 但是结果 [1, 3, 5] 在字典序上更大。
>
>输入：nums = [1,2,1,2,1,2,1,2,1], k = 2
>输出：[0,2,4]
>```
>
>
>提示：
>
>- 1 <= nums.length <= 2 * 10^4
>- 1 <= nums[i] < 2^16
>- 1 <= k <= floor(nums.length / 3)

恕我愚钝，答案这方法属实很妙。首先，我们知道的，我们可以维持 3 段滑动窗口，然后 3 次循环，解出来。不过时间复杂度是 `O(n^3)` ，显然会超时。其次，维持长度一直为 k 的子数组也需要滑动。而答案呢？把所有的滑动都放到了一次循环里。慢慢看我写的注释吧。

```c++
class Solution {
public:
    vector<int> maxSumOfThreeSubarrays(vector<int> &nums, int k) {
        vector<int> ans;
        // sum1 表示第一段的子数组和，sum2 表示第二段的子数组和，sum3 表示第三段的子数组和
        // maxSum1 表示第一段子数组和的最大值，maxSum12 表示前两段子数组和的最大值
        // maxTotal 表示三段子数组和的最大值
        // maxSum1Idx 表示第一个子数组取的下标
        // maxSum12Idx1, maxSum12Idx2 表示在确定前两个子数组和的最大值时的下标
        int sum1 = 0, maxSum1 = 0, maxSum1Idx = 0;
        int sum2 = 0, maxSum12 = 0, maxSum12Idx1 = 0, maxSum12Idx2 = 0;
        int sum3 = 0, maxTotal = 0;
        for (int i = k * 2; i < nums.size(); ++i) {
            // 首先加 k 次，从 k * 2 到 k * 3 - 1，这样长度就是 k 了
            sum1 += nums[i - k * 2];
            sum2 += nums[i - k];
            sum3 += nums[i];
            // 满足长度了之后
            if (i >= k * 3 - 1) {
              	// 表示第一段子数组可以更大了
                if (sum1 > maxSum1) {
                    // 更新最大值和下标索引
                    maxSum1 = sum1;
                    maxSum1Idx = i - k * 3 + 1;
                }
                // 这里取的是当前第一段子数组的最大值和当前的第二段子数组两个和的最大值
                // 这是最妙的一个地方。如果取的是第一段子数组的最大值和第二段子数组的最大值之和
                // 就会出问题，因为都是前面确定的，可能会冲突，就不满足互不重叠的条件了
                // 第一段的最大值是在前面确定好的，而第二段的用的是当前的，就避免了冲突
                if (maxSum1 + sum2 > maxSum12) {
                    // 更新最大值和下标索引
                    maxSum12 = maxSum1 + sum2;
                    maxSum12Idx1 = maxSum1Idx;
                    maxSum12Idx2 = i - k * 2 + 1;
                }
                // 同上
                if (maxSum12 + sum3 > maxTotal) {
                    maxTotal = maxSum12 + sum3;
                    ans = {maxSum12Idx1, maxSum12Idx2, i - k + 1};
                }
                sum1 -= nums[i - k * 3 + 1];
                sum2 -= nums[i - k * 2 + 1];
                sum3 -= nums[i - k + 1];
            }
        }
        return ans;
    }
};
```

动态规划。属于是很基本的动态规划了。不过问题出在，怎么确定下标呢？ `dp[n][3]` 表示的是子数组的最大和。属于是长见识了。因为要按照字典序最小取，所以先反转数组。[三叶姐姐题解](https://leetcode-cn.com/problems/maximum-sum-of-3-non-overlapping-subarrays/solution/gong-shui-san-xie-jie-he-qian-zhui-he-de-ancx/)。

```c++
class Solution {
public:
    vector<int> maxSumOfThreeSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        reverse(nums.begin(), nums.end());
        vector<int> sum(n + 1, 0);
        for (int i = 1; i <= n; i++)
            sum[i] = sum[i - 1] + nums[i - 1];
        vector<vector<int>> dp(n + 1, vector<int>(4, 0));
        // 如果包括第 i 个数字和不包括第 i g数字
        for (int i = k; i <= n; i++) {
            for (int j = 1; j < 4; j++) {
                dp[i][j] = max(dp[i - 1][j], dp[i - k][j - 1] + sum[i] - sum[i - k]);
            }
        }
        vector<int> ans(3, 0);
        int i = n, j = 3, idx = 0;
        while (j > 0) {
            // 意思就是锁 dp[i][j] = dp[i - 1][j], 即不包括第 i 歌数字
            if (dp[i - 1][j] > dp[i - k][j - 1] + sum[i] - sum[i - k]) {
                i--;
            } else { // 包括第 i 歌数字
                ans[idx++] = n - i;
                i -= k;
                j--;
            }
        }
        return ans;
    }
};
```

### 748、最短补全词

>给你一个字符串 licensePlate 和一个字符串数组 words ，请你找出并返回 words 中的 最短补全词 。
>
>补全词 是一个包含 licensePlate 中所有字母的单词。
>
>在匹配 licensePlate 中的字母时：
>
>忽略 licensePlate 中的 数字和空格 。
>
>不区分大小写。
>
>如果某个字母在 licensePlate 中出现不止一次，那么该字母在补全词中的出现次数应当一致或者更多。
>例如：licensePlate = "aBc 12c"，那么它的补全词应当包含字母 'a'、'b' （忽略大写）和两个 'c' 。可能的 补全词 有 "abccdef"、"caaacab" 以及 "cbca" 。
>
>请你找出并返回 words 中的 最短补全词 。题目数据保证一定存在一个最短补全词。当有多个单词都符合最短补全词的匹配条件时取 words 中 第一个 出现的那个。
>
>```
>示例：
>
>输入：licensePlate = "1s3 PSt", words = ["step", "steps", "stripe", "stepple"]
>输出："steps"
>解释：最短补全词应该包括 "s"、"p"、"s"（忽略大小写） 以及 "t"。
>"step" 包含 "t"、"p"，但只包含一个 "s"，所以它不符合条件。
>"steps" 包含 "t"、"p" 和两个 "s"。
>"stripe" 缺一个 "s"。
>"stepple" 缺一个 "s"。
>因此，"steps" 是唯一一个包含所有字母的单词，也是本例的答案。
>
>输入：licensePlate = "1s3 456", words = ["looks", "pest", "stew", "show"]
>输出："pest"
>解释：licensePlate 只包含字母 "s" 。所有的单词都包含字母 "s" ，其中 "pest"、"stew"、和 "show" 三者最短。答案是 "pest" ，因为它是三个单词中在 words 里最靠前的那个。
>
>输入：licensePlate = "Ah71752", words = ["suggest","letter","of","husband","easy","education","drug","prevent","writer","old"]
>输出："husband"
>
>输入：licensePlate = "OgEu755", words = ["enough","these","play","wide","wonder","box","arrive","money","tax","thus"]
>输出："enough"
>
>输入：licensePlate = "iMSlpe4", words = ["claim","consumer","student","camera","public","never","wonder","simple","thought","use"]
>输出："simple"
>```
>
>
>提示：
>
>- 1 <= licensePlate.length <= 7
>- licensePlate 由数字、大小写字母或空格 ' ' 组成
>- 1 <= words.length <= 1000
>- 1 <= words[i].length <= 15
>- words[i] 由小写英文字母组成

不会用 vector 的排序，所以只能用 C 写了。（其实也没有必要排序）在用 C++ 排序的时候发现问题了，题干中的最后一句话，因此，不能排序。 只能说我过了是运气。

```c
int comp(void const *a, void const *b)
{
    int _a = strlen(*(char **)a);
    int _b = strlen(*(char **)b);
    return _a > _b;
}
bool judge(char *a, int *sign)
{
    int myjudge = true;
    // 匹配
    for (int i = 0; i < strlen(a); i++) {
        sign[a[i] - 'a']--;
    }
    // 如果有大于 0 的，则不能补全
    for (int i = 0; i < 26; i++) {
        if (sign[i] > 0)
            myjudge = false;
    }
    // 恢复
    for (int i = 0; i < strlen(a); i++) {
        sign[a[i] - 'a']++;
    }
    return myjudge;
}
char * shortestCompletingWord(char * licensePlate, char ** words, int wordsSize){
    int sign[26];
    memset(sign, 0, sizeof(sign));
    for (int i = 0; i < strlen(licensePlate); i++) {
        if (licensePlate[i] >= 'a' && licensePlate[i] <= 'z')
            sign[licensePlate[i] - 'a']++;
        else if (licensePlate[i] >= 'A' && licensePlate[i] <= 'Z')
            sign[licensePlate[i] - 'A']++;
    }
    // 从短到长排序
    qsort(words, wordsSize, sizeof(char *), comp);
    // 测试语句
    for (int i = 0; i < wordsSize; i++)
        printf("%s ", words[i]);
    for (int i = 0; i < wordsSize; i++) {
        if (judge(words[i], sign)) {
            return words[i];
        }
    }
    return NULL;
}
```

不过 C++ 用稳定排序即可。

```c++
bool comp(string a, string b) {
    return a.size() < b.size();
}
stable_sort(words.begin(), words.end(), comp);
```

### 794、有效的井字游戏

>给你一个字符串数组 board 表示井字游戏的棋盘。当且仅当在井字游戏过程中，棋盘有可能达到 board 所显示的状态时，才返回 true 。
>
>井字游戏的棋盘是一个 3 x 3 数组，由字符 ' '，'X' 和 'O' 组成。字符 ' ' 代表一个空位。
>
>以下是井字游戏的规则：
>
>- 玩家轮流将字符放入空位（' '）中。
>- 玩家 1 总是放字符 'X' ，而玩家 2 总是放字符 'O' 。
>- 'X' 和 'O' 只允许放置在空位中，不允许对已放有字符的位置进行填充。
>- 当有 3 个相同（且非空）的字符填充任何行、列或对角线时，游戏结束。
>- 当所有位置非空时，也算为游戏结束。
>- 如果游戏结束，玩家不允许再放置字符。
>
>```
>示例：
>
>输入：board = ["O  ","   ","   "]
>输出：false
>解释：玩家 1 总是放字符 "X" 。
>
>输入：board = ["XOX"," X ","   "]
>输出：false
>解释：玩家应该轮流放字符。
>
>输入：board = ["XXX","   ","OOO"]
>输出：false
>
>输入：board = ["XOX","O O","XOX"]
>输出：true
>```
>
>**提示：**
>
>- `board.length == 3`
>- `board[i].length == 3`
>- `board[i][j]` 为 `'X'`、`'O'` 或 `' '`

分类讨论即可。

```C++
class Solution {
public:
    bool validTicTacToe(vector<string>& board) {
        int xcount = count(board, 'X'), ocount = count(board, 'O');
        bool xwin = win(board, 'X'), owin = win(board, 'O');
        // 两个人都赢，不行
        if (xwin && owin) return false;
        // X赢了，但是X的数量不比O多，不行
        else if (xwin && xcount - ocount != 1) return false;
        // O赢了，但是X的数量和O不相等，不行
        else if (owin && xcount - ocount != 0) return false;
        // X的数量和O的数量差不是0或1，不行
        else if (xcount - ocount < 0 || xcount - ocount > 1)    return false;
        else    return true;
    }
    bool win(vector<string>& board, char c) {
        for (int i = 0; i < 3; i++) {
            // 横着一样
            if (board[i][0] == c && board[i][1] == c && board[i][2] == c)
                return true;
            // 横着一样
            if (board[0][i] == c && board[1][i] == c && board[2][i] == c)
                return true;
        }
        // 斜着一样
        if (board[0][0] == c && board[1][1] == c && board[2][2] == c)
            return true;
        if (board[0][2] == c && board[1][1] == c && board[2][0] == c)
            return true;
        return false;
    }
    // 计数
    int count(vector<string>& board, char c) {
        int count = 0;
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                if (board[i][j] == c)
                    count++;
            }
        }
        return count;
    }
};
```

### 709、转换成小写字母

>给你一个字符串 s ，将该字符串中的大写字母转换成相同的小写字母，返回新的字符串。
>
>```
>示例：
>
>输入：s = "Hello"
>输出："hello"
>
>输入：s = "here"
>输出："here"
>
>输入：s = "LOVELY"
>输出："lovely"
>```
>
>
>提示：
>
>- 1 <= s.length <= 100
>- s 由 ASCII 字符集中的可打印字符组成

#### 调用API

```c++
class Solution {
public:
    string toLowerCase(string s) {
        for (char& ch: s) {
            ch = tolower(ch);
        }
        return s;
    }
};
```

#### 自己写API

![image-20211214102350500](https://gitee.com/ceyewan/pic/raw/master/images/image-20211214102350500.png)

```C++
class Solution {
public:
    string toLowerCase(string s) {
        for (char& ch: s) {// 遍历
            // +32
            if (ch >= 65 && ch <= 90) {
                ch |= 32;
            }
        }
        return s;
    }
};
```

### 807、保持城市的天际线

>给你一座由 n x n 个街区组成的城市，每个街区都包含一座立方体建筑。给你一个下标从 0 开始的 n x n 整数矩阵 grid ，其中 `grid[r][c]` 表示坐落于 r 行 c 列的建筑物的 高度 。
>
>城市的 天际线 是从远处观察城市时，所有建筑物形成的外部轮廓。从东、南、西、北四个主要方向观测到的 天际线 可能不同。
>
>我们被允许为 任意数量的建筑物 的高度增加 任意增量（不同建筑物的增量可能不同） 。 高度为 0 的建筑物的高度也可以增加。然而，增加的建筑物高度 不能影响 从任何主要方向观察城市得到的 天际线 。
>
>在 不改变 从任何主要方向观测到的城市 天际线 的前提下，返回建筑物可以增加的 最大高度增量总和 。
>
>![img](https://gitee.com/ceyewan/pic/raw/master/images/807-ex1.png)
>
>```
>示例：
>
>输入：grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]
>输出：35
>解释：建筑物的高度如上图中心所示。
>用红色绘制从不同方向观看得到的天际线。
>在不影响天际线的情况下，增加建筑物的高度：
>gridNew = [ [8, 4, 8, 7],
>            [7, 4, 7, 7],
>            [9, 4, 8, 7],
>            [3, 3, 3, 3] ]
>```
>
>**提示：**
>
>- `n == grid.length`
>- `n == grid[r].length`
>- `2 <= n <= 50`
>- `0 <= grid[r][c] <= 100`

确定每行和每列的最大高度，则 `grid[i][j]` 能增加的最大高度就是 `min(dp1[i], dp2[j]) - grid[i][j]` ，一定是个大于等于 0 的数。

```C++
class Solution {
public:
    int maxIncreaseKeepingSkyline(vector<vector<int>>& grid) {
        int n = grid.size();
        vector<int> dp1(n, 0);// dp1[i]表示第 i 行的最大高度
        vector<int> dp2(n, 0);// dp2[j]表示第 j 行的最大高度
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                dp1[i] = max(dp1[i], grid[i][j]);
                dp2[j] = max(dp2[j], grid[i][j]);
            }
        }
        int ans = 0;
        for (int i = 0; i < n; i++) {
            for(int j = 0; j < n; j++) {
                ans += min(dp1[i], dp2[j]) - grid[i][j];
            }
        }
        return ans;
    }
};
```

### 911、在线选举

>给你两个整数数组 persons 和 times 。在选举中，第 i 张票是在时刻为 times[i] 时投给候选人 persons[i] 的。
>
>对于发生在时刻 t 的每个查询，需要找出在 t 时刻在选举中领先的候选人的编号。
>
>在 t 时刻投出的选票也将被计入我们的查询之中。在平局的情况下，最近获得投票的候选人将会获胜。
>
>实现 TopVotedCandidate 类：
>
>- TopVotedCandidate(int[] persons, int[] times) 使用 persons 和 times 数组初始化对象。
>- int q(int t) 根据前面描述的规则，返回在时刻 t 在选举中领先的候选人的编号。
>
>```
>示例：
>
>输入：
>["TopVotedCandidate", "q", "q", "q", "q", "q", "q"]
>[[[0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]], [3], [12], [25], [15], [24], [8]]
>输出：
>[null, 0, 1, 1, 0, 0, 1]
>
>解释：
>TopVotedCandidate topVotedCandidate = new TopVotedCandidate([0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]);
>topVotedCandidate.q(3); // 返回 0 ，在时刻 3 ，票数分布为 [0] ，编号为 0 的候选人领先。
>topVotedCandidate.q(12); // 返回 1 ，在时刻 12 ，票数分布为 [0,1,1] ，编号为 1 的候选人领先。
>topVotedCandidate.q(25); // 返回 1 ，在时刻 25 ，票数分布为 [0,1,1,0,0,1] ，编号为 1 的候选人领先。（在平局的情况下，1 是最近获得投票的候选人）。
>topVotedCandidate.q(15); // 返回 0
>topVotedCandidate.q(24); // 返回 0
>topVotedCandidate.q(8); // 返回 1
>```
>
>
>提示：
>
>- 1 <= persons.length <= 5000
>- times.length == persons.length
>- 0 <= persons[i] < persons.length
>- 0 <= times[i] <= 10^9
>- times 是一个严格递增的有序数组
>- times[0] <= t <= 10^9
>- 每个测试用例最多调用 10^4 次 q

```C++
class TopVotedCandidate {
public:
    vector<int> tops;
    vector<int> times;

    TopVotedCandidate(vector<int>& persons, vector<int>& times) {
        // 哈希表
        unordered_map<int, int> voteCounts;
        voteCounts[-1] = -1;
        int top = -1;
        for (auto &p :persons) {
            // p 的票数增加 1
            voteCounts[p]++;
            // 如果 p 的票数多于或等于票数第一的那个人（top）
            if (voteCounts[p] >= voteCounts[top]) {
                // 票数第一就是 p
                top = p;
            }
            // 将此时的 top 放进top中
            tops.emplace_back(top);
        }
        this->times = times;
    }
    
    int q(int t) {
        // upper_bound() 函数定义在头文件中，用于在指定范围内查找大于目标值的第一个元素
        int pos = upper_bound(times.begin(), times.end(), t) - times.begin() - 1;
        // 找到这个时间对应的位置，tops中这个位置就是这个时间票数最高的人
        return tops[pos];
    }
};
/**
 * Your TopVotedCandidate object will be instantiated and called as such:
 * TopVotedCandidate* obj = new TopVotedCandidate(persons, times);
 * int param_1 = obj->q(t);
 */
```

### 1610、可见点的最大数量

>给你一个点数组 points 和一个表示角度的整数 angle ，你的位置是 location ，其中 location = [posx, posy] 且 points[i] = [xi, yi] 都表示 X-Y 平面上的整数坐标。
>
>最开始，你面向东方进行观测。你 不能 进行移动改变位置，但可以通过 自转 调整观测角度。换句话说，posx 和 posy 不能改变。你的视野范围的角度用 angle 表示， 这决定了你观测任意方向时可以多宽。设 d 为你逆时针自转旋转的度数，那么你的视野就是角度范围 [d - angle/2, d + angle/2] 所指示的那片区域。
>
>对于每个点，如果由该点、你的位置以及从你的位置直接向东的方向形成的角度 位于你的视野中 ，那么你就可以看到它。
>
>同一个坐标上可以有多个点。你所在的位置也可能存在一些点，但不管你的怎么旋转，总是可以看到这些点。同时，点不会阻碍你看到其他点。
>
>返回你能看到的点的最大数目。
>
> ![img](https://gitee.com/ceyewan/pic/raw/master/images/89a07e9b-00ab-4967-976a-c723b2aa8656.png)
>
>```
>示例：
>
>输入：points = [[2,1],[2,2],[3,3]], angle = 90, location = [1,1]
>输出：3
>解释：阴影区域代表你的视野。在你的视野中，所有的点都清晰可见，尽管 [2,2] 和 [3,3]在同一条直线上，你仍然可以看到 [3,3] 。
>
>输入：points = [[2,1],[2,2],[3,4],[1,1]], angle = 90, location = [1,1]
>输出：4
>解释：在你的视野中，所有的点都清晰可见，包括你所在位置的那个点
>```
>
>![img](https://gitee.com/ceyewan/pic/raw/master/images/5010bfd3-86e6-465f-ac64-e9df941d2e49.png)
>
>```
>输入：points = [[1,0],[2,1]], angle = 13, location = [1,1]
>输出：1
>解释：如图所示，你只能看到两点之一。
>```
>
>提示：
>
>- 1 <= points.length <= 105
>- points[i].length == 2
>- location.length == 2
>- 0 <= angle < 360
>- 0 <= posx, posy, xi, yi <= 100

将所有的点和位置点的角度求出来，然后范围是360度，然后截取其中的 angle 度，使得这个范围内包含的点最多。

```C
#define PI 3.1415926
#define MAX(a, b) ((a) > (b) ? (a) : (b))

int comp(const void *a, const void *b)
{
    double *pa = (double *)a;
    double *pb = (double *)b;
    return *pa > *pb ? 1 : -1;
}

int binarySearch(double* nums, int numsSize, double target) {
    int left = 0, right = numsSize - 1;
    int ans = 0;
    while (left <= right) {
        int mid = (left + right) / 2;
        if (nums[mid] > target) {
            right = mid - 1;
            ans = mid;
        } else {
            left = mid + 1;
        }
    }
    return ans;
}

int visiblePoints(int** points, int pointsSize, int* pointsColSize, int angle, int* location, int locationSize){
    int sameCnt = 0; // 记录和原点重合的点的数量
    int polarSize = 0;// 角度数组的长度
    // 原始角度的范围是360度以内，偏移角度也有360度，所以我们把角度数组翻个倍
    double *polarDegrees = (double *)malloc(sizeof(double) * pointsSize * 2);
    for (int i = 0; i < pointsSize; i++) {
        // 重合
        if (points[i][0] == location[0] && points[i][1] == location[1]) {
            sameCnt++;
            continue;
        }
        // 否则求出角度
        double degree = atan2(points[i][1] - location[1], points[i][0] - location[0]);
        // 加入到数组中
        polarDegrees[polarSize++] = degree;
    }
    // for (int i = 0; i < polarSize; i++)
    //     printf("%f ", polarDegrees[i]);
    // 将角度排序
    qsort(polarDegrees, polarSize, sizeof(double), comp);
    // 拷贝一份
    int m = polarSize;
    for (int i = 0; i < m; ++i) {
        polarDegrees[polarSize] = polarDegrees[i] + 2 * PI;
        polarSize++;
    }
    int maxCnt = 0;
    // 将角度转换为弧度制，或者前面转换为角度制
    double degree = angle * PI / 180.0;
    // printf("%d", sameCnt);
    for (int i = 0; i < m; ++i) {
        // 把起始边角度定为第 i 个点的角度，然后逆时针偏转 degree
        // 二分查找不大于polarDegrees[i] + degree的最后一个值的下标
        int iteration = binarySearch(polarDegrees, polarSize, polarDegrees[i] + degree);
        maxCnt = MAX(maxCnt, iteration - i);
    }
    return maxCnt + sameCnt;
}
```

- 这里还可以用滑动窗口写，控制窗口的长度不超过 angle 即可。
- 也可以把弧度制转换为角度值。
- 这里是把数组包括的角度范围拓展成（-π，3π），可以拓展成（0，4π）或者（0，720）

### 851、喧闹与富有

>有一组 `n` 个人作为实验对象，从 `0` 到 `n - 1` 编号，其中每个人都有不同数目的钱，以及不同程度的安静值（quietness）。为了方便起见，我们将编号为 `x` 的人简称为 `"person x "`。
>
>给你一个数组 `richer` ，其中 `richer[i] = [ai, bi]` 表示 `person ai` 比 `person bi` 更有钱。另给你一个整数数组 `quiet` ，其中 `quiet[i]` 是 `person i` 的安静值。`richer` 中所给出的数据 逻辑自洽（也就是说，在 `person x` 比 `person y` 更有钱的同时，不会出现 `person y` 比 `person x` 更有钱的情况 ）。
>
>现在，返回一个整数数组 `answer` 作为答案，其中 `answer[x] = y` 的前提是，在所有拥有的钱肯定不少于 `person x` 的人中，`person y` 是最安静的人（也就是安静值 `quiet[y]` 最小的人）。
>
>示例 1：
>
>```
>输入：richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]
>输出：[5,5,2,5,4,5,6,7]
>解释： 
>answer[0] = 5，
>person 5 比 person 3 有更多的钱，person 3 比 person 1 有更多的钱，person 1 比 person 0 有更多的钱。
>唯一较为安静（有较低的安静值 quiet[x]）的人是 person 7，
>但是目前还不清楚他是否比 person 0 更有钱。
>answer[7] = 7，
>在所有拥有的钱肯定不少于 person 7 的人中（这可能包括 person 3，4，5，6 以及 7），
>最安静（有较低安静值 quiet[x]）的人是 person 7。
>其他的答案也可以用类似的推理来解释。
>```
>
>示例 2：
>
>```
>输入：richer = [], quiet = [0]
>输出：[0]
>```
>
>提示：
>
>- `n == quiet.length`
>- `1 <= n <= 500`
>- `0 <= quiet[i] < n`
>- `quiet 的所有值 互不相同`
>- `0 <= richer.length <= n * (n - 1) / 2`
>- `0 <= ai, bi < n`
>- `ai != bi`
>- `richer` 中的所有数对 互不相同
>- 对 `richer` 的观察在逻辑上是一致的

#### dfs

```C
void dfs(int x, int *quiet, int **g, int n, int *ans)
{
    // 如果求出来了，就不用重复求了
    if (ans[x] != -1)   return;
    // 先设为自己
    ans[x] = x;
    for (int i = 0; i < n; i++) {
        // 如果 i 比 x 有钱
        if (g[x][i] == 1) {
            // 求出 i 的 ans
            dfs(i, quiet, g, n, ans);
            // 如果 i 中那个人的安静值小于本身
            if ((quiet[ans[i]] < quiet[ans[x]]))
                // 则 x 的ans 需要设置为 ans[i]
                ans[x] = ans[i];
        }
    }
}
int* loudAndRich(int** richer, int richerSize, int* richerColSize, int* quiet, int quietSize, int* returnSize){
    int n = quietSize;
    int *ans = (int *)malloc(sizeof(int) * n);
    memset(ans, -1, sizeof(int) * n);
    // 建立邻接矩阵
    int **g = (int *)malloc(sizeof(int *) * n);
    for (int i = 0; i < n; i++) {
        g[i] = (int *)malloc(sizeof(int) * n);
        memset(g[i], 0, sizeof(int) * n);
    }
    for (int i = 0; i < richerSize; i++) {
        g[richer[i][1]][richer[i][0]] = 1; // g[i][j] 表示 j 比 i 有钱
    }
    // dfs(i) 计算第第 i 个人富有的人中安静值最小的那个人，将那个人存在 ans[i] 中
    for (int i = 0; i < n; i++)
        dfs(i, quiet, g, n, ans);
    *returnSize = n;
    return ans;
}
```

C++邻接表

```C++
vector<vector<int>> g(n);
for (auto &r : richer) {
	g[r[1]].emplace_back(r[0]);
}
```

python邻接表

```python
g = [[] for _ in range(n)]
for r in richer:
	g[r[1]].append(r[0])
```

这两个写的都好简洁，哭了。

#### 拓扑排序

我们可以将方法一中的图的边全部反向，即如果 ai 比 bi 更有钱，我们从 ai 向 bi 连一条有向边。这同样得到的是一张有向无环图，因此我们从图上任意一点（设为 x）出发，沿着有向边所能访问到的点，拥有的钱都比 x 少。这意味着我们可以在计算出 answer[x] 后，用 answer[x] 去更新 x 所能访问到的点的 answer 值。
要实现这一算法，我们可以将每个 answer[x] 初始化为 x，然后对这张图执行一遍拓扑排序，并按照拓扑序去更新 x 的邻居的 answer 值。通过这一方式我们就能将 answer[x] 的值「传播」到 x 所能访问到的点上。

入度为 0 ，说明是最富有的，因此 ans 是自身。

```C
int* loudAndRich(int** richer, int richerSize, int* richerColSize, int* quiet, int quietSize, int* returnSize){
    int n = quietSize;
    // 先设置为自身
    int *ans = (int *)malloc(sizeof(int) * n);
    for (int i = 0; i < n; i++)
        ans[i] = i;
    // 建立邻接矩阵和入度表
    int *inDeg = (int *)malloc(sizeof(int) * n);
    memset(inDeg, 0, sizeof(int) * n);
    int **g = (int *)malloc(sizeof(int *) * n);
    for (int i = 0; i < n; i++) {
        g[i] = (int *)malloc(sizeof(int) * n);
        memset(g[i], 0, sizeof(int) * n);
    }
    for (int i = 0; i < richerSize; i++) {
        g[richer[i][0]][richer[i][1]] = 1; // g[i][j] 表示 i 比 j 有钱
        inDeg[richer[i][1]] += 1; // richer[i][1]入度加 1
    }
    // 将所有入度为 0 的点入栈，不能用循环，因为循环开始的时候可能入度还不是 0 ，后面入度变成 0 就不会再考虑了
    int stack[n];
    int top = -1;
    for (int i = 0; i < n; i++) {
        if (inDeg[i] == 0) {
            stack[++top] = i;
        }
    }
    // 栈不为空
    while (top != -1) {
        // 出栈
        int i = stack[top--];
        for (int j = 0; j < n; j++) {
            // i 比 j 富有，而且 j 的入度一定大于 0
            if (g[i][j] == 1) {
                // 可以用 i 的来更新 j 的
                if (quiet[ans[i]] < quiet[ans[j]])
                    ans[j] = ans[i];
                // 入度减 1
                inDeg[j] -= 1;
                // 入栈
                if (inDeg[j] == 0)
                    stack[++top] = j;
            }
        }
    }
    *returnSize = n;
    return ans;
}
```

### 1518、换酒问题

>小区便利店正在促销，用 numExchange 个空酒瓶可以兑换一瓶新酒。你购入了 numBottles 瓶酒。
>
>如果喝掉了酒瓶中的酒，那么酒瓶就会变成空的。
>
>请你计算 最多 能喝到多少瓶酒。

示例 1：

![img](https://gitee.com/ceyewan/pic/raw/master/images/sample_1_1875.png)

```
输入：numBottles = 9, numExchange = 3
输出：13
解释：你可以用 3 个空酒瓶兑换 1 瓶酒。
所以最多能喝到 9 + 3 + 1 = 13 瓶酒。
```

示例 2：

![img](https://gitee.com/ceyewan/pic/raw/master/images/sample_2_1875.png)

```
输入：numBottles = 15, numExchange = 4
输出：19
解释：你可以用 4 个空酒瓶兑换 1 瓶酒。
所以最多能喝到 15 + 3 + 1 = 19 瓶酒。
```

示例 3：

```
输入：numBottles = 5, numExchange = 5
输出：6
```

示例 4：

```
输入：numBottles = 2, numExchange = 3
输出：2
```


提示：

- `1 <= numBottles <= 100`
- `2 <= numExchange <= 100`

#### 模拟

```C
int numWaterBottles(int numBottles, int numExchange){
    int bottle = 0;
    int sum = 0;
    // 还有酒
    while (numBottles) {
        sum += numBottles; // 喝掉
        bottle += numBottles; // 更新瓶子
        numBottles = bottle / numExchange; // 换酒
        bottle %= numExchange; // 剩下的瓶子
    }
    return sum;
}
```

#### 数学

numExchange 个瓶子换一瓶酒（即 一份酒水和一个瓶子），也即 numExchange - 1 个瓶子可以换 1 瓶酒水。而且我们必须至少留一个瓶子在手上，瓶子不可能全换光（不考虑脑筋急转弯情况，借一个瓶子）。那么原本有 numBottles 瓶酒，即 numBottles - 1 个可以用来换的瓶子，可以换 （numBottles - 1） / （numExchange - 1）瓶酒水。没除尽说明不止剩一个瓶子。

```C
int numWaterBottles(int numBottles, int numExchange){
    return numBottles + (numBottles - 1) / (numExchange - 1);
}
```

### 630、课程表Ⅲ

>这里有 `n` 门不同的在线课程，按从 `1` 到 `n` 编号。给你一个数组 `courses` ，其中 `courses[i] = [durationi, lastDayi]` 表示第 `i` 门课将会 持续 上 `durationi` 天课，并且必须在不晚于 `lastDayi` 的时候完成。
>
>你的学期从第 `1` 天开始。且不能同时修读两门及两门以上的课程。
>
>返回你最多可以修读的课程数目。

示例 1：

```
输入：courses = [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]
输出：3
解释：
这里一共有 4 门课程，但是你最多可以修 3 门：
首先，修第 1 门课，耗费 100 天，在第 100 天完成，在第 101 天开始下门课。
第二，修第 3 门课，耗费 1000 天，在第 1100 天完成，在第 1101 天开始下门课程。
第三，修第 2 门课，耗时 200 天，在第 1300 天完成。
第 4 门课现在不能修，因为将会在第 3300 天完成它，这已经超出了关闭日期。
```

示例 2：

```
输入：courses = [[1,2]]
输出：1
```

示例 3：

```
输入：courses = [[3,2],[4,3]]
输出：0
```


提示:

- `1 <= courses.length <= 10^4`
- `1 <= durationi, lastDayi <= 10^4`

#### 优先队列 + 贪心

对于两门课 `(t_1, d_1)`和 `(t_2, d_2)`，如果后者的关闭时间较晚，即 `d_1 <= d_2`，那么我们先学习前者，再学习后者，总是最优的。

因此，我们可以讲所有的课程按照关闭时间 `d` 进行升序排序，再依次挑选课程并按照顺序进行学习。

![image-20211216141953862](https://gitee.com/ceyewan/pic/raw/master/images/image-20211216141953862.png)

#### 代码

```C
// 这个地方返回值写成了 bool ，debug找了好久
int comp(const void *a, const void *b)
{
    int *a1 = *(int**)a;
    int *b1 = *(int**)b;
	// ddl相等，先做需要时间短的
    if (a1[1] == b1[1]) {
        return a1[0] - b1[0];
    }
    // ddl近的优先
    return a1[1] - b1[1];
}
// 最大堆
int *nums;
int heapSize;
// 插入元素
void push(int x)
{
    int i = heapSize;
    // 插在末尾，然后上移
    nums[heapSize++] = x;
    bool judge = false;
    while (i > 0 && !judge) {
        if (nums[i] > nums[(i - 1) / 2]) {
            int temp = nums[i];
            nums[i] = nums[(i - 1) / 2];
            nums[(i - 1) / 2] = temp;
        } else {
            judge = true;
        }
        i = (i - 1) / 2;
    }
}
// 删除最大值，插入一个值（我们就用这个插入的值替换掉最大值，然后下移
void replace(int x)
{
    nums[0] = x;
    bool judge = false;
    int i = 0;
    while (!judge) {
        int left = 2 * i + 1, right = 2 * i + 2;
        if (left >= heapSize)   return;
        int key = nums[left] > nums[right] ? left : right;
        if (nums[i] < nums[key]) {
            int temp = nums[i];
            nums[i] = nums[key];
            nums[key] = temp;
        } else {
            judge = true;
        }
        i = key;
    }
}
int scheduleCourse(int** courses, int coursesSize, int* coursesColSize){
    // 快排，ddl越近的排在前头
    qsort(courses, coursesSize, sizeof(int *), comp);
    // 优先队列
    nums = (int *)malloc(sizeof(int) * coursesSize);
    heapSize = 0;
    // 需要的上课时长
    int total = 0;
    for (int i = 0; i < coursesSize; i++) {
        int ti = courses[i][0], di = courses[i][1];
        // 如果这个课可以直接上
        if (total + ti <= di) {
            total += ti;
            push(ti);
        } 
        // total + ti > di,说明现在没办法多上一门课了
        // 如果 nums[0](上的课中时间最长的课) > ti ,我们可以把那门课换成 ti 这门课
        // 虽然现在并不能多上课，但是可以多腾点时间给之后的课用（贪心思想）
        else if (heapSize > 0 && nums[0] > ti) {
            total = total - nums[0] + ti;
            replace(ti);
        }
    }
    return heapSize;
}
```

### 419、甲板上的战舰

>给你一个大小为 m x n 的矩阵 board 表示甲板，其中，每个单元格可以是一艘战舰 'X' 或者是一个空位 '.' ，返回在甲板 board 上放置的 战舰 的数量。
>
>战舰 只能水平或者垂直放置在 board 上。换句话说，战舰只能按 1 x k（1 行，k 列）或 k x 1（k 行，1 列）的形状建造，其中 k 可以是任意大小。两艘战舰之间至少有一个水平或垂直的空位分隔 （即没有相邻的战舰）。
>

示例 1：

```
输入：board = [["X",".",".","X"],[".",".",".","X"],[".",".",".","X"]]
输出：2
```


示例 2：

```
输入：board = [["."]]
输出：0
```


提示：

- m == board.length
- n == board[i].length
- 1 <= m, n <= 200
- `board[i][j]` 是 '.' 或 'X'

进阶：

- 你可以实现一次扫描算法，并只使用 O(1) 额外空间，并且不修改 board 的值来解决这个问题吗？

学了点并查集，所以来秀一手。

```C
int *parents;
int count;
// 初始化并查集，每个元素的父节点都是自己
void init(int x)
{
    parents = (int *)malloc(sizeof(int) * x);
    for (int i = 0; i < x; i++) 
        parents[i] = i;
}
// 查找x的祖先节点
int find(int x)
{
    // 如果父节点不是自己本身
    while (parents[x] != x) {
        // 父节点是父节点的父节点（路径压缩）
        parents[x] = parents[parents[x]];
        // x设置为父节点的父节点
        x = parents[x];
    }
    return x;
}
// 合并两个节点
void Union(int x, int y)
{
    int x1 = find(x);
    int y1 = find(y);
    // 如果祖先节点不同，那么就设置为相同
    if (x1 != y1) {
        parents[x1] = y1;
        // 节点数量减一
        count--;
    }
}
int countBattleships(char** board, int boardSize, int* boardColSize){
    int m = boardSize, n = boardColSize[0];
    // 初始化
    init(m * n);
    // 最开始有 count 个节点
    count = m * n;
    // 是空位的节点数量
    int white = 0;
    // 遍历
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            // 空位
            if (board[i][j] == '.')
                white++;
            // 战舰
            else {
                // 如果是相邻战舰，则合并为同一艘战舰
                if (i > 0 && board[i - 1][j] == 'X')
                    Union(i * n + j, (i - 1) * n + j);
                if (i < m - 1 && board[i + 1][j] == 'X')
                    Union(i * n + j, (i + 1) * n + j);
                if (j > 0 && board[i][j - 1] == 'X')
                    Union(i * n + j, i * n + j - 1);
                if (j < n - 1 && board[i][j + 1] == 'X')
                    Union(i * n + j, i * n + j + 1);
            }
        }
    }
    free(parents);
    // 总数量减去空地数量就是战舰数量
    return count - white;
}
```

进阶，我们想一下，这里的战舰都是横着或者竖着的，那么我们可以用最左上角（当作战舰头）表示一艘战舰，其他的不管。

```C
int countBattleships(char** board, int boardSize, int* boardColSize){
    int m = boardSize, n = boardColSize[0];
    int count = 0;
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            // 是战舰头才计数
            if (board[i][j] == 'X' && (i == 0 || board[i - 1][j] == '.') && /
                (j == 0 || board[i][j - 1] == '.')) {
                count++;
   
            }
        }
    }
    return count;
}
```

### 997、小镇的法官

> 在一个小镇里，按从 1 到 n 为 n 个人进行编号。传言称，这些人中有一个是小镇上的秘密法官。
>
> 如果小镇的法官真的存在，那么：
>
> 小镇的法官不相信任何人。
> 每个人（除了小镇法官外）都信任小镇的法官。
> 只有一个人同时满足条件 1 和条件 2 。
> 给定数组 trust，该数组由信任对 trust[i] = [a, b] 组成，表示编号为 a 的人信任编号为 b 的人。
>
> 如果小镇存在秘密法官并且可以确定他的身份，请返回该法官的编号。否则，返回 -1。
>

示例 1：

```
输入：n = 2, trust = [[1,2]]
输出：2
```

示例 2：

```
输入：n = 3, trust = [[1,3],[2,3]]
输出：3
```

示例 3：

```
输入：n = 3, trust = [[1,3],[2,3],[3,1]]
输出：-1
```

示例 4：

```
输入：n = 3, trust = [[1,2],[2,3]]
输出：-1
```

示例 5：

```
输入：n = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]]
输出：3
```


提示：

- 1 <= n <= 1000
- 0 <= trust.length <= 104
- trust[i].length == 2
- trust[i] 互不相同
- `trust[i][0]` != `trust[i][1]`
- 1 <= trust[i][0], trust[i][1] <= n

讲道理这种题应该算中等的，结果居然是简单。建图

```C
int findJudge(int n, int** trust, int trustSize, int* trustColSize){
    int **graph = (int **)malloc(sizeof(int *) * (n + 1));
    for (int i = 0; i < n + 1; i++) {
        graph[i] = (int *)malloc(sizeof(int) * (n + 1));
        memset(graph[i], 0, sizeof(int) * (n + 1));
    }
    for (int i = 0; i < trustSize; i++) {
        graph[trust[i][0]][trust[i][1]] = 1;
    }
    for (int i = 1; i < n + 1; i++) {
        bool judge = true;
        for (int j = 1; j < n + 1; j++) {
            if (j != i && graph[j][i] == 0) {
                judge = false;
                break;
            }
            if (j != i && graph[i][j] == 1) {
                judge = false;
                break;
            }
        }
        if (judge)  return i;
    }
    return -1;
}
```

其实没必要建图，有个入度和出度的概念即可。

```C
int findJudge(int n, int** trust, int trustSize, int* trustColSize){
    int inDeg[n + 1];
    int outDeg[n + 1];
    memset(inDeg, 0, sizeof(inDeg));
    memset(outDeg, 0, sizeof(outDeg));
    for (int i = 0; i < trustSize; i++) {
        inDeg[trust[i][1]]++;
        outDeg[trust[i][0]]++;
    }
    for (int i = 1; i < n + 1; i++) {
        if (inDeg[i] == n - 1 && outDeg[i] == 0)
            return i;
    }
    return -1;
}
```

### 475、供暖器

>冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。
>
>在加热器的加热半径范围内的每个房屋都可以获得供暖。
>
>现在，给出位于一条水平线上的房屋 houses 和供暖器 heaters 的位置，请你找出并返回可以覆盖所有房屋的最小加热半径。
>
>说明：所有供暖器都遵循你的半径标准，加热的半径也一样。

示例 1:

```
输入: houses = [1,2,3], heaters = [2]
输出: 1
解释: 仅在位置2上有一个供暖器。如果我们将加热半径设为1，那么所有房屋就都能得到供暖。
```

示例 2:

```
输入: houses = [1,2,3,4], heaters = [1,4]
输出: 1
解释: 在位置1, 4上有两个供暖器。我们需要将加热半径设为1，这样所有房屋就都能得到供暖。
```

示例 3：

```
输入：houses = [1,5], heaters = [2]
输出：3
```


提示：

- 1 <= houses.length, heaters.length <= 3 * 10^4
- 1 <= houses[i], heaters[i] <= 10^9

对于每一所房子，要么用前面的供暖器，要么用后面的。我们把供暖器排序，这样就可以用二分查找了。

快排 + 二分查找

```C
int comp(void const *a, void const *b)
{
    // 看数据，这里不能用减号
    return *(int *)a > *(int *)b;
}
// 二分查找大于等于target的第一个值的下标
int b_search(int *nums, int s, int t, int target)
{
    int left = s, right = t;
    while (left <= right) {
        int mid = (left + right) / 2;
        if (nums[mid] >= target && (mid == 0 || nums[mid - 1] < target))
            return mid;
        else if (nums[mid] < target)
            left = mid + 1;
        else
            right = mid - 1;
    }
    return right;
}
int findRadius(int* houses, int housesSize, int* heaters, int heatersSize){
    qsort(heaters, heatersSize, sizeof(int), comp);
    int ans = 0;
    // return ans;
    for (int i = 0; i < housesSize; i++) {
        // 所有供暖器都在房子右边
        if (houses[i] <= heaters[0])
            ans = fmax(ans, heaters[0] - houses[i]);
        // 所有供暖器都在房子左边
        else if (houses[i] >= heaters[heatersSize - 1])
            ans = fmax(ans, houses[i] - heaters[heatersSize - 1]);
        // 一定左边有右边也有
        else {
            // printf("%d", houses[i]);
            int temp = b_search(heaters, 0, heatersSize - 1, houses[i]);
            // printf("%d", temp);
            int min = fmin(heaters[temp] - houses[i], houses[i] - heaters[temp - 1]);
            ans = fmax(min, ans);
        }
    }
    return ans;
}
```

快排 + 双指针

```C
#define MAX(a, b) ((a) > (b) ? (a) : (b))
#define ABS(a) ((a) >= 0 ? (a) : (-(a)))

int comp(void const *a, void const *b)
{
    // 看数据，这里不能用减号
    return *(int *)a - *(int *)b;
}
int findRadius(int* houses, int housesSize, int* heaters, int heatersSize){
    qsort(houses, housesSize, sizeof(int), comp);
    qsort(heaters, heatersSize, sizeof(int), comp);
    int i = 0, j = 0, ans = 0;
    while (i < housesSize && j < heatersSize) {
        /*为什么一定要有等号呢？没有等号错了一个输入*/
        while (j < heatersSize - 1 && 
               ABS(heaters[j + 1] - houses[i]) <= ABS(heaters[j] - houses[i]))
            j++;
        ans = MAX(ans, ABS(heaters[j] - houses[i]));
        // printf("%d", ans);
        i++;
    }
    return ans;
}
```

解答上面的疑问。因为啊，相等的时候不一定是一左一右（比如房子是4，供暖器是3和5），可能是都在左边（比如房子是4，供暖器是3和3），这样的话，j 不动，房子继续动，变成5，j 还是不动。就卡住了。究其原因，就是供暖器可能有重复。

### 1154、一年中的第几天

> 给你一个字符串 date ，按 YYYY-MM-DD 格式表示一个 现行公元纪年法 日期。请你计算并返回该日期是当年的第几天。
>
> 通常情况下，我们认为 1 月 1 日是每年的第 1 天，1 月 2 日是每年的第 2 天，依此类推。每个月的天数与现行公元纪年法（格里高利历）一致。
>

示例 1：

```
输入：date = "2019-01-09"
输出：9
```

示例 2：

```
输入：date = "2019-02-10"
输出：41
```

示例 3：

```
输入：date = "2003-03-01"
输出：60
```

示例 4：

```
输入：date = "2004-03-01"
输出：61
```


提示：

- date.length == 10
- date[4] == date[7] == '-'，其他的 date[i] 都是数字
- date 表示的范围从 1900 年 1 月 1 日至 2019 年 12 月 31 日

这里简单梳理一下思路，然后翻译成代码就好了。
1. 把每个月有多少天都用个数组记录下来，二月暂定为29天

2. 根据字符串转换成为数字，求出年月日，格式固定是 `YYYY-MM-DD`

3. 将前面几个月的天数全部加起来

4. 再加上今天是这个月的第几天

5. 如果是闰年并且今天是2月之后的再加一（因为前面少加了一天）（2月多一天）

6. 闰年的条件是:

​    	一:能被4整除，但不能被100整除的年份(例如2008是闰年，1900不是闰年) 

​    	二:能被400整除的年份(例如2000年)也是闰年。

```C
int months[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
int dayOfYear(char * date){
    int year = (date[0] - '0') * 1000 + (date[1] - '0') * 100 + (date[2] - '0') * 10 + date[3] - '0';
    int month = (date[5] - '0') * 10 + date[6] - '0';
    int day = (date[8] - '0') * 10 + date[9] - '0';
    int ans = 0;
    for (int i = 0; i < month - 1; i++) {
        ans += months[i];
    }
    ans += day;
    if (((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) && month > 2) {
        ans += 1;
    }
    return ans;
}
```

学点新知识：atoi 函数，将字符串转换为整数，包括正负，不包括小数点，遇到其他字符或 '\0' 停止

```C
int dayOfYear(char * date){
    int year = atoi(date);
    int month = atoi(date + 5);
    int day = atoi(date + 8);
    int amount[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    if (year % 400 == 0 || (year % 4 == 0 && year % 100 != 0)) {
        ++amount[1];
    }
    int ans = 0;
    for (int i = 0; i < month - 1; ++i) {
        ans += amount[i];
    }
    return ans + day;
}
```

### 686、重复叠加字符串匹配

>给定两个字符串 a 和 b，寻找重复叠加字符串 a 的最小次数，使得字符串 b 成为叠加后的字符串 a 的子串，如果不存在则返回 -1。
>
>注意：字符串 "abc" 重复叠加 0 次是 ""，重复叠加 1 次是 "abc"，重复叠加 2 次是 "abcabc"。

示例 1：

```
输入：a = "abcd", b = "cdabcdab"
输出：3
解释：a 重复叠加三遍后为 "abcdabcdabcd", 此时 b 是其子串。
```

示例 2：

```
输入：a = "a", b = "aa"
输出：2
```

示例 3：

```
输入：a = "a", b = "a"
输出：1
```

示例 4：

```
输入：a = "abc", b = "wxyz"
输出：-1
```


提示：

- 1 <= a.length <= 10^4
- 1 <= b.length <= 10^4
- a 和 b 由小写英文字母组成

前一段日子看 STL ，发现 string 容器有一个 find 函数，这解决子串问题不是神器吗？

> string 中 find() 返回值是子串在母串中的位置（下标记录），如果没有找到，那么会返回一个特别的标记 npos 。（返回值可以看成是一个 int 型的数）

好了，下面我们分析一下：

1. 例如案例 2 ，复制的次数是 bSize / aSize

2. 例如示例 1 ，复制的次数是 bSize / aSize + 1

3. 例如：a = "abcd" , b = "dabcdabcda" ,需要复制 bSize / aSize + 2 次，得到 "abc**dabcdabcda**bcd"

4. 只有这三种可能，再多复制也只是重复了

5. 那么我们就对这三种情况分别应用 find 函数，如果查找到了就返回对应的复制次数

```C++
class Solution {
public:
    int repeatedStringMatch(string a, string b) {
        int aSize = a.size(), bSize = b.size();
        int k = bSize / aSize;
        string ans1 = "";
        for (int i = 0; i < k; i++) {
            ans1 += a;
        }
        // cout << ans1 << endl;
        string ans2 = ans1 + a;
        string ans3 = ans2 + a;
        cout << ans1.find(b) << endl;
        if (ans1.find(b) != ans1.npos)
            return k;
        else if (ans2.find(b) != ans2.npos)
            return k + 1;
        else if (ans3.find(b) != ans3.npos)
            return k + 2;
        return -1;
    }
};
```

### 最长重复子串

### 1705、吃苹果的最大数目

>有一棵特殊的苹果树，一连 n 天，每天都可以长出若干个苹果。在第 i 天，树上会长出 apples[i] 个苹果，这些苹果将会在 days[i] 天后（也就是说，第 i + days[i] 天时）腐烂，变得无法食用。也可能有那么几天，树上不会长出新的苹果，此时用 apples[i] == 0 且 days[i] == 0 表示。
>
>你打算每天 最多 吃一个苹果来保证营养均衡。注意，你可以在这 n 天之后继续吃苹果。
>
>给你两个长度为 n 的整数数组 days 和 apples ，返回你可以吃掉的苹果的最大数目。

示例 1：

```
  输入：apples = [1,2,3,5,2], days = [3,2,1,4,2]
  输出：7
  解释：你可以吃掉 7 个苹果：
  - 第一天，你吃掉第一天长出来的苹果。
  - 第二天，你吃掉一个第二天长出来的苹果。
  - 第三天，你吃掉一个第二天长出来的苹果。过了这一天，第三天长出来的苹果就已经腐烂了。
  - 第四天到第七天，你吃的都是第四天长出来的苹果。
```

 示例 2：

```
  输入：apples = [3,0,0,0,0,2], days = [3,0,0,0,0,2]
  输出：5
  解释：你可以吃掉 5 个苹果：
  
  - 第一天到第三天，你吃的都是第一天长出来的苹果。
  - 第四天和第五天不吃苹果。
  - 第六天和第七天，你吃的都是第六天长出来的苹果。
```


提示：

- apples.length == n
- days.length == n
- 1 <= n <= 2 * 10^4
- 0 <= apples[i], days[i] <= 2 * 10^4
- 只有在 apples[i] = 0 时，days[i] = 0 才成立

贪心 + 优先队列

为了将吃苹果的数目最大化，应该使用贪心策略，在尚未腐烂的苹果中优先选择腐烂日期最早的苹果。

为了得到腐烂日期最早的苹果，可以使用优先队列存储每个苹果的腐烂日期，优先队列中最小的元素（即最早的腐烂日期）会最先被取出。

1. 将优先队列中的所有腐烂日期小于等于当前日期的元素取出，这些元素表示已经腐烂的苹果，无法食用；

2. 根据 days 和 apples 的当前元素计算当天长出的苹果的腐烂日期和数量，如果数量大于 0，则将腐烂日期和数量加入优先队列；

3. 如果优先队列不为空，则当天可以吃 1 个苹果，将优先队列的队首元素的数量减 1，如果队首元素的数量变成 0 则将队首元素取出。

```C++
typedef pair<int, int> pii; // 数对

class Solution {
public:
    int eatenApples(vector<int>& apples, vector<int>& days) {
        int ans = 0;
        // 优先队列，元素是pii，数据结构是vector，类型是小顶堆（greater）大顶堆可以忽略不写
        priority_queue<pii, vector<pii>, greater<pii>> pq;
        int n = apples.size();
        int i = 0;
        while (i < n) {
            // 优先队列不为空，并且队首第一个元素比 i 要小
            while (!pq.empty() && pq.top().first <= i) {
                // 出队，即腐烂
                pq.pop();
            }
            // 这一天的苹果腐烂日期和数量
            int rottenDay = i + days[i];
            int count = apples[i];
            // 如果非 0，则入队
            if (count > 0) {
                pq.emplace(rottenDay, count);
            }
            // 队列不为空，吃一个队顶的苹果
            if (!pq.empty()) {
                pii curr = pq.top();
                pq.pop();
                curr.second--;
                // 如果吃了一个之后还有苹果，那么又入队
                if (curr.second != 0) {
                    pq.emplace(curr.first, curr.second);
                }
                ans++;
            }
            i++;
        }
        // 所有的苹果都入队了，还能吃的话
        while (!pq.empty()) {
            while (!pq.empty() && pq.top().first <= i) {
                pq.pop();
            }
            if (pq.empty()) {
                break;
            }
            pii curr = pq.top();
            pq.pop();
            // 腐烂日期和苹果数量的最小值
            int num = min(curr.first - i, curr.second);
            ans += num;
            i += num;
        }
        return ans;
    }
};
```

C语言手写优先队列，优先队列的好处就是降低时间复杂度。

```C
typedef struct {
    int rottenday;
    int count;
}Apple;
Apple *heap;
int basicSize;
int heapSize;
void down()
{
    int i = 0, next;
    int left = 1, right = 2;
    while (left < heapSize) {
        if (right < heapSize && heap[right].rottenday < heap[left].rottenday)
            next = right;
        else next = left;
        if (heap[next].rottenday < heap[i].rottenday) {
            Apple temp = heap[next];
            heap[next] = heap[i];
            heap[i] = temp;
        } else
            break;
        i = next;
        left = 2 * next + 1, right = 2 * next + 2;
    }
}
void up()
{
    int i = heapSize - 1, next;
    while (i > 0) {
        next = (i - 1) / 2;
        if (heap[next].rottenday > heap[i].rottenday) {
            Apple temp = heap[next];
            heap[next] = heap[i];
            heap[i] = temp;
        } else
            break;
        i = next;
    }
}
int eatenApples(int* apples, int applesSize, int* days, int daysSize){
    heapSize = 0;
    basicSize = 8;
    heap = (Apple *)malloc(sizeof(Apple) * basicSize);
    int ans = 0, i = 0;
    while (i < applesSize) {
        while (heapSize > 0 && heap[0].rottenday <= i) {
            heap[0] = heap[--heapSize];
            down();
        }
        int rottenday = i + days[i];
        int count = apples[i];
        if (count > 0) {
            if (heapSize == basicSize) {
                basicSize *= 2;
                heap = (Apple *)realloc(heap, sizeof(Apple) * basicSize);
            }
            heap[heapSize].rottenday = rottenday;
            heap[heapSize++].count = count;
            up();
        }
        if (heapSize > 0) {
            count = heap[0].count - 1;
            if (count > 0) {
                heap[0].count = count;
            } else {
                heap[0] = heap[--heapSize];
                down();
            }
            ans++;
        }
        i++;
    }
    while (heapSize > 0 && heap[0].rottenday <= i) {
        heap[0] = heap[--heapSize];
        down();
    }
    while (heapSize > 0) {
        Apple temp = heap[0];
        heap[0] = heap[--heapSize];
        down();
        int num = fmin(temp.rottenday - i, temp.count);
        ans += num;
        i += num;
    }
    return ans;
}
```

### 1609、奇偶树

>如果一棵二叉树满足下述几个条件，则可以称为 奇偶树 ：
>
>二叉树根节点所在层下标为 0 ，根的子节点所在层下标为 1 ，根的孙节点所在层下标为 2 ，依此类推。
>偶数下标 层上的所有节点的值都是 奇 整数，从左到右按顺序 严格递增
>奇数下标 层上的所有节点的值都是 偶 整数，从左到右按顺序 严格递减
>给你二叉树的根节点，如果二叉树为 奇偶树 ，则返回 true ，否则返回 false 。

示例 1:

![img](https://gitee.com/ceyewan/pic/raw/master/images/sample_1_1966.png)

```
输入：root = [1,10,4,3,null,7,9,12,8,6,null,null,2]
输出：true
解释：每一层的节点值分别是：
0 层：[1]
1 层：[10,4]
2 层：[3,7,9]
3 层：[12,8,6,2]
由于 0 层和 2 层上的节点值都是奇数且严格递增，而 1 层和 3 层上的节点值都是偶数且严格递减，因此这是一棵奇偶树。
```


提示：

- 树中节点数在范围 [1, 10^5] 内
- 1 <= Node.val <= 10^6

bfs 层序遍历。

```C
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
#define MAX 1000001
typedef struct {
    int level;  // 层数
    struct TreeNode *node;  // 节点
}Qu;
Qu queue[MAX];
bool isEvenOddTree(struct TreeNode* root){
    // bfs层序遍历
    int left = 0, right = 0;
    queue[right].level = 0;
    queue[right++].node = root;
    while (left < right) {
        int level = queue[left].level;
        struct TreeNode *temp = queue[left++].node;
        if (temp->left != NULL) {
            queue[right].level = level + 1;
            queue[right++].node = temp->left;
        }
        if (temp->right != NULL) {
            queue[right].level = level + 1;
            queue[right++].node = temp->right;
        }
    }
    left = 0;
    while (left < right) {  
        // 避免越界 层数相同 如果是偶数层不递增 如果是奇数层不递减
        if (left < right - 1 && queue[left + 1].level == queue[left].level &&
        ((queue[left].level % 2 == 0 && queue[left + 1].node->val <= queue[left].node->val) || 
        (queue[left].level % 2 == 1 && queue[left + 1].node->val >= queue[left].node->val)))
            return false;
        // 层数和数字奇偶性相同
        if ((queue[left].level + queue[left].node->val) % 2 == 0)
            return false;
        left++;
    }
    return true;
}
```



